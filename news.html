<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cumbia: news</title>
<link href="html/cumbia/html/tabs.css" rel="stylesheet" type="text/css"/>
</head>

<body>
<h1>News</h1>

<h2>version 1.2.0</h2>

The cumbia version 1.2.0 moves definitely towards the application portability and aims at broader integration
across several engines (that translates into <em>cumbia modules</em>).
Alongside the <em>websocket</em> integration, cumbia 1.2.0 introduces initial support to <em>http and
Server Sent Events</em> technologies, looking forward to such services becoming available soon.
Applications written in any language will thus be enabled to connect to native control system engines from
<em>anywhere</em>.

<h3>New quapps.pri project include file</h3>
<p>
The <em>qumbia-apps</em> module includes a new <em>quapps</em> utility that offers automatic
cumbia module (engine) detection at application startup.
Just include <strong>quapps.pri</strong> from your <em>path/to/cumbia-libs/include/quapps</em> to use the
CuModuleLoader helper class.
</p>

<h3>Tango Database read access becomes easy!</h3>
<p>
Reading class properties is accomplished by a source like <em>tango://TangoTest(ProjectTitle,Description)</em>
Device properties can be obtained like <em>tango://ken:20000/test/device/1(description, helperApplication,values)</em>,
and get the list of attributes of a device through <em>ken:20000/test/device/1(description, helperApplication,values)</em>
</p>
<p>
Type <br/>
<em>cumbia read --help</em><br/>
and scroll to the section <em>Read the Tango database</em> to play and get acquainted with this new functionality in no time!
</p>
<p>
This new feature allows to get properties in your app with just the little code needed for usual sources, and integrate
them easily in graphical elements.
Have a look at <a href="https://elettra-sincrotronetrieste.github.io/cumbia-libs/html/cumbia-qtcontrols/html/understanding_cumbia_qtcontrols_constructors.html">this</a>
documentation page.
</p>

<h3>cumbia-http</h3>
<p>
Nowadays the need to access control systems from home and portable devices is constantly growing.
The new <em>cumbia-http</em> has been designed with this purpose and http and Server Sent Event services in mind.
When such services become available, clients of any kind will be able to connect from anywhere!
</p><p>
Include <em>cumbia-http</em> in your installation is as easy as adding <strong>http</strong> to the <em>scripts/cubuild.sh</em>
command.
</p>

<h3>CuModuleLoader loader in quapps</h3>
<p>
The new header file provided by *qumbia-apps/quapps* module allows to find and load all
available cumbia engines, depending on optional command line arguments. Thanks to this
and to the flexible cumbia design, it is possible to connect any application to a native
control system engine or let it obtain data through *http* or *websocket*.
</p>

<h3>QTango migration creates a multi engine version of the app</h3>
<p>
The cumbia project wizard now creates a <em>multi engine</em> version of the application when
migrating from a QTango project.
</p>

<h2>version 1.1.1</h2>

<h3>cumbia</h3>
<ul>
<li>CumbiaPool: removed printf when no implementation is found and improved doc</li>
<li>Support for cross compilation with emscripten / wasm</li>
</ul>

<h3>cumbia-qtcontrols</h3>
<ul>
<li>CuControlsFactoryPool: NULL replaced with nullptr.</li>
<li> A QuReplaceWildcards_I definition has been introduced to provide an interface for command line *replace wildcards* capable
    engines.</li>
<li> Support for cross compilation with emscripten / wasm</li>
</ul>

<h3>qumbia-apps</h3>
<ul>
<li>qumbia-read: support for websocket</li>
</ul>
<ul>qumbiaprojectwizard:
<li>fixed $APPLICATION_NAME$" and "$ORGANIZATION_NAME$" placeholder replacement</li>
<li>multi-engine is the default option and the templates create a skeleton including cumbia-random and cumbia-websocket modules,
     if available. cumbia-websocket is added only if a proper command line option is detected. QCommandLineParser is used to find
     the required option to activate cumbia-websocket connection</li>
</ul>

<h3>cumbia-websocket</h3>
<ul>
<li>added support for a full-duplex communication with generic server on a single web socket.
    Former support to canoned (pwma) server is maintained and selected if an http url is provided
    to the constructor alongside the websocket URL.</li>
<li>d1. can be tested using the simple https://github.com/ELETTRA-SincrotroneTrieste/cumbia-websocket-proxy-server.git
    websocket server "proxy"</li>
<li>added support for command line argument wildcard replacement for tango by an implementation of QuReplaceWildcards_I</li>
</ul>

<h3>qumbia-tango-controls</h3>
<ul>
<li>cutcontrols-utils:  CuTangoReplaceWildcards implementation of the QuReplaceWildcards_I interface is used to perform
    command line arguments wildcard replacement</li>
</ul>

<h2>version 1.1.0</h2>


<h2>App: cumbia read</h2>
<p>
<a href="html/qumbia-reader/html/index.html">cumbia read</a> has been expanded in order to support the cumbia-random module and a
great number of command line options.
Coupled with the qumbia-tango-findsrc-plugin and the qumbia-tango-find-src app, that can be installed from
<a href="https://github.com/ELETTRA-SincrotroneTrieste/qumbia-tango-findsrc-plugin.git">github</a>.
it provides <cite>Tango sources auto completion</cite> on the command line.
</p>
<h3>Try it out!</h3>

<p>
<cite>Hint</cite>: hit the <em>TAB</em> key to auto complete Tango source names.
</p>

<style>

  table {
    border-collapse: collapse;
  }
  th, td {
    border: 1px solid orange;
    padding: 10px;
    text-align: left;
  }
</style>

<table>
<tr><th>description</th><th>command</th></tr>
<tr><td>read sources from heterogeneous engines</td>
<td>cumbia read test/device/1/double_scalar epics:ai1 random://rnd/1/0/10  </td> </tr>
<tr><td>read sources configuration only, from heterogeneous engines</td>
<td>cumbia read test/device/1/double_scalar epics:ai1 --property </tr>
<tr><td>Impart a Tango command to read an array three times, truncate the output to 8 elements, print with a custom format</td>
<td>cumbia read inj/diagnostics/rtbpm_inj.01//GetHorPos[0,1000] --truncate=8 --3 --format="%.4f" </tr>
<tr><td>Monitor a Tango command</td>
<td>cumbia monitor inj/diagnostics/rtbpm_inj.01//GetHorPos[0,1000] --truncate=8</td> </tr>
<tr><td>Filtered list of Tango device properties</td>
<td>cumbia read --tp  test/device/1:helper*  </td></tr>
<tr><td>Read a Tango attribute property</td>
<td>cumbia read --tp test/device/1/string_scalar/values  </td></tr>
</table>

<p>
More examples <a href="html/qumbia-reader/html/index.html">here</a>.
</p>

<p>
Additional features:
<ul>
<li>customizable output detail level</li>
<li>support for Tango database properties (device, attribute, class)</li>
<li>either monitor or single shot mode</li>
See the documentation for a more detailed description.
</ul>
</p>

<h2>Library</h2>

<h3>New prerequisites</h3>
<p>
    The read/write locks adopted to provide greater speed require a compiler supporting the <em>C++ 17</em> standard.
</p>

<h3> cumbia </h3>
<p>
Version 1.1.0 allows the application developer to customize how threads are grouped together, as well
as to define an upper limit on their number. The *cumbia-tango* engine groups threads by Tango device.
If you want to customize the default behaviour, refer to the
<a href="html/cumbia-tango/html/classCuTThreadTokenGen.html">CuTThreadTokenGen</a> and the
<a href="html/cumbia/html/classCumbia.html#ad1294d5af961ea0899aabf299e7f2c56">Cumbia::setThreadTokenGenerator</a>
documentation pages.
Additionally, timers in polled reads can be reused in order to limit timer threads.
See the <a href="html/cumbia/html/classCuTimerService.html">CuTimerService</a> documentation.
</p>

<h3>cumbia-tango</h3>
<h4>Database search
<p>
CuTdbPropertyReader
<ul>
<li>added support for wildcards when searching device properties</li>
<li>added Tango class property list for a given class name</li>
</ul>
</p>

<h3>cumbia-random</h3>
<p>
<a href="html/cumbia-random/html/index.html">cumbia-random</a>
has been expanded in order to offer great flexibility to test higher level cumbia modules
and applications with greater accuracy. Source names alone can specify how data is generated, threads grouped and much more. JavaScript
functions in .js files can be set as source of data for the cumbia-random module.
</p>
<ul>
<li>The source name can define group threading, period, size of generated data, minimum, maximum and period.</li>
<li>The source can specify a JavaScript file to generate data from a custom function</li>
</ul>

<h3>cumbia-qtcontrols</h3>
<p>
CuPluginLoader provides a template method to quickly obtain an instance of the desired plugin. See
<a href="html/cumbia-qtcontrols/html/classCuPluginLoader.html">CuPluginLoader</a>::get.
</p>


<h2>Plugins</h2>
<h3>qumbia-tango-findsrc-plugin</h3>
<p>
 An external new plugin named qumbia-tango-findsrc-plugin and the qumbia-tango-find-src app are available from
   <a href="https://github.com/ELETTRA-SincrotroneTrieste/qumbia-tango-findsrc-plugin.git">github.com</a>
   The utility finds the name of a Tango source (attribute or command) from a partial name.
   <em>The plugin can be loaded from any application willing to provide <strong>Tango sources auto completion</strong></em>.
</p>


</body>
