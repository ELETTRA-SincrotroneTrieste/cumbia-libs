<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>qumbia-tango-controls: Writing a Qt widget that integrates with cumbia</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">qumbia-tango-controls
   &#160;<span id="projectnumber">1.x</span>
   </div>
   <div id="projectbrief">Library on top of cumbia-qtcontrols and cumbia-tango</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Writing a Qt widget that integrates with cumbia </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this tutorial we will learn how to adapt a Qt widget to display data from an engine like Tango or Epics. In other words, we will write a <em>cumbia-qtcontrols</em> widget. The tutorial is inspired by QuLabel from the cumbia-qtcontrols library. See qulabel.h and qulabel.cpp for the complete widget.</p>
<h1>Interface design</h1>
<h2>Inheritance</h2>
<p>Let the widget inherit from the Qt widget suitable to display the data in the form you require. It must implement the CuDataListener interface in order to receive updates and CuContextI so that the clients can get a reference to the CuContext used by the object.</p>
<div class="fragment"><div class="line">#include &lt;QLabel&gt;</div>
<div class="line">#include &lt;cudatalistener.h&gt;</div>
<div class="line">#include &lt;cucontexti.h&gt;</div>
<div class="line">#include &lt;cudata.h&gt;</div>
<div class="line"> </div>
<div class="line">class QuLabel : public QLabel, public CuDataListener, public CuContextI</div>
<div class="line">{</div>
<div class="line">    Q_OBJECT</div>
</div><!-- fragment --><h2>The class constructor</h2>
<p>In order to offer maximum flexibility, two constructors should be provided:</p>
<div class="fragment"><div class="line">QuLabel(QWidget *w, Cumbia *cumbia, const CuControlsReaderFactoryI &amp;r_fac);</div>
<div class="line"> </div>
<div class="line">QuLabel(QWidget *w, CumbiaPool *cumbia_pool, const CuControlsFactoryPool &amp;fpool);</div>
</div><!-- fragment --><ul>
<li>w the parent widget </li>
<li>cumbia: a pointer to a Cumbia instance, typically the constructor will be called with a reference to CumbiaTango or CumbiaEpics </li>
<li>CuControlsReaderFactoryI: a const reference to a factory that instantiates the reader according to the engine in use: Tango (<a class="el" href="classCuTReaderFactory.html" title="this factory creates Tango readers. Options can be set.">CuTReaderFactory</a>) or Epics (CuEpReaderFactory). </li>
<li>CumbiaPool: a pointer to an object designed to configure the QuLabel at runtime according to the source provided for the reader. In other words, if CumbiaPool parametrizes QuLabel, Tango and Epics sources can be used, even together in the same application. </li>
<li>CuControlsFactoryPool: a const reference to a factory that allocates the appropriate reader depending on the source specified.</li>
</ul>
<h2>CuDataListener implementation</h2>
<p>Implementing CuDataListener implies writing the <em>onUpdate</em> method:</p>
<div class="fragment"><div class="line">void onUpdate(const CuData &amp;d);</div>
</div><!-- fragment --><p>The method will update the contents of the label.</p>
<h2>CuContextI implementation</h2>
<p>A method returning a pointer to the CuContext in use must be written:</p>
<div class="fragment"><div class="line">CuContext *getContext() const;</div>
</div><!-- fragment --><h2>Optional: store private class attributes into a private pointer (<em>bridge</em> pattern)</h2>
<p>To make a class binary compatible across several versions in the future, we choose to store the private attributes of the class into a <em>QuLabelPrivate</em> object.</p>
<div class="fragment"><div class="line">// after #include directives</div>
<div class="line"> </div>
<div class="line">class QuLabelPrivate; // will be defined in .cpp</div>
<div class="line"> </div>
<div class="line">class QuLabel : public QLabel, public CuDataListener, public CuContextI</div>
<div class="line">{</div>
<div class="line">    Q_OBJECT</div>
<div class="line">    </div>
<div class="line">    /* ... */</div>
<div class="line">    </div>
<div class="line">private:</div>
<div class="line">    QuLabelPrivate *d;</div>
<div class="line">};</div>
</div><!-- fragment --><h2>Reader configuration: source and setSource methods</h2>
<p>Two methods are provided to tell QuLabel the name of the connection end point. Methods names and usage will be familiar to QTango users:</p>
<div class="fragment"><div class="line">public:</div>
<div class="line">    QString source() const;</div>
<div class="line">    </div>
<div class="line">public slots:</div>
<div class="line">    void setSource(const QString&amp; s);</div>
</div><!-- fragment --><h2>Get link statistics and health through a right click menu on the widget</h2>
<p>The QuLabel can be designed to provide an option to show a dialog window with statistics on the readings, a plot of the trend of the variable (if scalar) and other piecese of information about the health of the link. To enable this feature, a special <em>Qt signal</em> must be defined and a contextMenuEvent implementation must be given, from where the signal is emitted. Add this to the header file:</p>
<div class="fragment"><div class="line">signals:</div>
<div class="line">    void linkStatsRequest(QWidget *myself, CuContextI *myself_as_cwi);</div>
<div class="line"> </div>
<div class="line">protected:</div>
<div class="line">    void contextMenuEvent(QContextMenuEvent* e);</div>
</div><!-- fragment --><h2>Class destructor</h2>
<p>Add the class destructor and the header file is now complete:</p>
<div class="fragment"><div class="line">public:</div>
<div class="line">    virtual ~QuLabel();</div>
</div><!-- fragment --><h1>cpp implementation</h1>
<p>The QuLabel interface has been designed; focus now on its implementation.</p>
<h2>Needed include files</h2>
<p>The following include files are needed to write the code that will follow.</p>
<div class="fragment"><div class="line">#include &lt;cucontrolsreader_abs.h&gt;</div>
<div class="line">#include &lt;cumbiapool.h&gt;</div>
<div class="line">#include &lt;cudata.h&gt;</div>
<div class="line">#include &lt;cucontrolsfactories_i.h&gt;</div>
<div class="line">#include &lt;cucontrolsfactorypool.h&gt;</div>
<div class="line">#include &lt;culinkstats.h&gt;</div>
<div class="line">#include &lt;cucontextmenu.h&gt;</div>
<div class="line">#include &lt;cucontext.h&gt;</div>
<div class="line"> </div>
<div class="line">#include &lt;QContextMenuEvent&gt;</div>
<div class="line">#include &lt;cumacros.h&gt; // for prints: perr, qstoc, printf...</div>
</div><!-- fragment --><h2>Private class attributes</h2>
<p>As discussed above, we decide to place the class attributes into a <em>private</em> class, applying the <em>bridge</em> design pattern to save future issues with binary compatibility across updates.</p>
<div class="fragment"><div class="line">class QuLabelPrivate</div>
<div class="line">{</div>
<div class="line">public:</div>
<div class="line">    bool read_ok;</div>
<div class="line">    CuContext *context;</div>
<div class="line">};</div>
</div><!-- fragment --><h2>Constructor implementation</h2>
<p>QLabel's constructor is invoked with the parent widget. The other two parameters are forwarded to the CuContext to delegate the connection setup depending on the chosen engine.</p>
<div class="fragment"><div class="line">QuLabel::QuLabel(QWidget *w, Cumbia *cumbia, const CuControlsReaderFactoryI &amp;r_factory) :</div>
<div class="line">    QLabel(w), CuDataListener()</div>
<div class="line">{</div>
<div class="line">    d = new QuLabelPrivate;</div>
<div class="line">    d-&gt;read_ok = false;</div>
<div class="line">    d-&gt;context = new CuContext(cumbia, r_factory);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">QuLabel::QuLabel(QWidget *w, CumbiaPool *cumbia_pool, const CuControlsFactoryPool &amp;fpool) :</div>
<div class="line">    QLabel(w), CuDataListener()</div>
<div class="line">{</div>
<div class="line">    d = new QuLabelPrivate;</div>
<div class="line">    d-&gt;read_ok = false;</div>
<div class="line">    d-&gt;context = new CuContext(cumbia_pool, fpool);</div>
<div class="line">}</div>
</div><!-- fragment --><h2>Destructor implementation</h2>
<div class="fragment"><div class="line">QuLabel::~QuLabel()</div>
<div class="line">{</div>
<div class="line">    delete d-&gt;context;</div>
<div class="line">    delete d;</div>
<div class="line">}</div>
</div><!-- fragment --><h2>source and setSource methods</h2>
<p>The setSource function will rely on the CuContext method to replace the existing source. Don't forget to call setSource on the CuControlsReader returned by the CuContext replace_reader call:</p>
<div class="fragment"><div class="line">void QuLabel::setSource(const QString &amp;s)</div>
<div class="line">{</div>
<div class="line">    CuControlsReaderA * r = d-&gt;context-&gt;replace_reader(s.toStdString(), this);</div>
<div class="line">    if(r)</div>
<div class="line">        r-&gt;setSource(s);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The source method gets a pointer to the reader from the CuContext and returns its source</p>
<div class="fragment"><div class="line">QString QuLabel::source() const</div>
<div class="line">{</div>
<div class="line">    if(CuControlsReaderA* r = d-&gt;context-&gt;getReader())</div>
<div class="line">        return r-&gt;source();</div>
<div class="line">    return &quot;&quot;;</div>
<div class="line">}</div>
</div><!-- fragment --><p>If no readers have been set up with setSource, then NULL is returned by CuContext::getReader and an empty string is in turn returned by source.</p>
<h2>Context menu event for statistics dialog</h2>
<p>Reimplement QWidget's virtual method <em>contextMenuEvent</em> and use the CuContextMenu menu as a means to request statistics, connecting its <em>linkStatsTriggered</em> signal to QuLabel's <em>linkStatsRequest</em> signal:</p>
<div class="fragment"><div class="line">void QuLabel::contextMenuEvent(QContextMenuEvent *e)</div>
<div class="line">{</div>
<div class="line">    CuContextMenu* m = new CuContextMenu(this, this);</div>
<div class="line">    connect(m, SIGNAL(linkStatsTriggered(QWidget*, CuContextI *)),</div>
<div class="line">            this, SIGNAL(linkStatsRequest(QWidget*, CuContextI *)));</div>
<div class="line">    m-&gt;popup(e-&gt;globalPos());</div>
<div class="line">}</div>
</div><!-- fragment --><h2>onUpdate: get data from the engine, format and display it on the label</h2>
<p>The last necessary piece of code receives the read data in input, extracts necessary information about errors, a message describing the result of the operation, the value and some other relevant fields. This is a simplified version of the <em>QuLabel::onUpdate</em> version, for educational purposes. A label displays data as text, so we declare a <em>QString</em> named <em>txt</em> for the purpose.<br  />
 The <em>read_ok</em> class attribute is updated early in the function, and the widget is disabled if an error occurred, to strike that the value is not available.<br  />
 Link statistics are then updated and, in case of error, the <em>addError</em> method is invoked to record the error within the CuContext link stats. In case of error, the string *"####"* is set on the label.<br  />
 The message is set as <em>QWidget tooltip</em> and the value is extracted by the CuVariant paired with the *"value"* key in the CuData bundle.</p>
<div class="fragment"><div class="line">void QuLabel::onUpdate(const CuData &amp;da)</div>
<div class="line">{</div>
<div class="line">    QString txt;</div>
<div class="line">    d-&gt;read_ok = !da[&quot;err&quot;].toBool();</div>
<div class="line">    setEnabled(d-&gt;read_ok);</div>
<div class="line"> </div>
<div class="line">    // update link statistics</div>
<div class="line">    d-&gt;context-&gt;getLinkStats()-&gt;addOperation();</div>
<div class="line">    if(!d-&gt;read_ok)</div>
<div class="line">        d-&gt;context-&gt;getLinkStats()-&gt;addError(da[&quot;msg&quot;].toString());</div>
<div class="line"> </div>
<div class="line">    setToolTip(da[&quot;msg&quot;].toString().c_str());</div>
<div class="line"> </div>
<div class="line">    if(da[&quot;err&quot;].toBool() )</div>
<div class="line">        setText(&quot;####&quot;);</div>
<div class="line">    else if(da.containsKey(&quot;value&quot;))</div>
<div class="line">    {</div>
<div class="line">        CuVariant val = da[&quot;value&quot;];</div>
<div class="line">        txt = QString::fromStdString(val.toString());</div>
<div class="line">        setText(txt);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The written code is enough to make a <em>Qt QLabel</em> read from an engine like Tango and Epics.</p>
<p>Let's now see how a client uses the new label. If you create a new cumbia project with the <em>qumbiaprojectwizard</em> application (see <a href="../html/md_src_tutorial_qumbiatango_app.html">Setting up a graphical application with cumbia and tango</a>), you will have the necessary variables automatically declared for you and ready to use.</p>
<p>If you choose <em>tango</em> as engine in the <em>qumbiaprojectwizard</em>, your main class declaration will contain something like this in the <em>private</em> section:</p>
<div class="fragment"><div class="line">private:</div>
<div class="line">    Ui::MycumbiatangoWidget *ui;</div>
<div class="line"> </div>
<div class="line">    CumbiaTango *cu_t;</div>
<div class="line">    CuTReaderFactory cu_tango_r_fac;</div>
<div class="line">    CuTWriterFactory cu_tango_w_fac;</div>
</div><!-- fragment --><p>The <em>cu_t</em> and <em>cu_tango_r_fac</em> class attributes are what you need to instantiate the new <em>label</em>. Supposing to instantiate the label in the MycumbiatangoWidget constructor:</p>
<div class="fragment"><div class="line">Mycumbiatangoapp::Mycumbiatangoapp(CumbiaTango *cut, QWidget *parent) :</div>
<div class="line">    QWidget(parent),</div>
<div class="line">    ui(new Ui::MycumbiatangoWidget)</div>
<div class="line">{</div>
<div class="line">    ui-&gt;setupUi(this, cu_t, cu_tango_r_fac, cu_tango_w_fac);</div>
<div class="line">    </div>
<div class="line">    QuLabel *mylabel = new QuLabel(this, cu_t, cu_tango_r_fac);</div>
<div class="line">    mylabel-&gt;setSource(&quot;$1/double_scalar&quot;); // set Tango source</div>
<div class="line">    </div>
<div class="line">    // add mylabel to layout and so on...</div>
<div class="line">}</div>
</div><!-- fragment --><h2>See also</h2>
<ul>
<li><a href="../html/md_src_tutorial_qumbiatango_app.html">Setting up a graphical application with cumbia and tango</a>. </li>
<li><a href="../../cuuimake/html/md_src_cuuimake.html">Using <em>cuuimake</em></a>.</li>
</ul>
<ul>
<li><a href="../../cumbia-qtcontrols/html/index.html">cumbia-qtcontrols module</a>. </li>
<li><a href="../html/index.html">qumbia-tango-controls module</a>. </li>
<li><a href="../../cumbia-epics/index.html">qumbia-epics module</a>. </li>
<li><a href="../../qumbia-epics-controls/html/index.html">qumbia-epics-controls module</a>. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Apr 10 2020 16:18:13 for qumbia-tango-controls by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
