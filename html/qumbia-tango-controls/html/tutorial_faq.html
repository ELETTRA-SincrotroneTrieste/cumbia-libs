<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>qumbia-tango-controls: Frequently Asked Questions (Tango)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">qumbia-tango-controls
   &#160;<span id="projectnumber">1.x</span>
   </div>
   <div id="projectbrief">Library on top of cumbia-qtcontrols and cumbia-tango</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Frequently Asked Questions (Tango) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h3>Table of contents</h3>
<ul>
<li><a href="#newproj">Is there a way to quickly set up a new cumbia project?</a></li>
<li><a href="#migrate">Is there a way to migrate a QTango project into a cumbia one?</a></li>
<li><a href="#cudata">What is the default structure used to exchange data by cumbia library? How do I use it?</a></li>
<li><a href="#readatt">What is the quickest way to read a Tango attribute in a cumbia application</a></li>
<li><a href="#state">What's the quickest procedure to display a Tango <em>state</em> and possibly get the associated color?</a></li>
<li><a href="#cudata_keys">How did you know that the <em>res</em> CuData contained those very keys such as "value", "state_color", "timestamp_ms", and so on.. ?</a></li>
<li><a href="#stdvector_string_to_qvector_qstringlist">How to quickly convert std::vector/std::string-based data in CuData to more Qt friendly QVector/QStringList/QStringList ?</a></li>
<li><a href="#commands">A quick way to perform a command inout on a device</a></li>
<li><a href="#cumbiawidget">In QTango there used to be a widget ready to read and display a value. In cumbia there is not. How do I quickly adapt an existing Qt widget?</a></li>
<li><a href="#cumbiawidget_props">How do I fetch specific Tango attribute properties to configure my custom cumbia widget?</a></li>
<li><a href="#configure">I either used QuWatcher or implemented CuDataListener on my custom graphical object. How do I configure it through the Tango database properties (setting maximum and minimum values, display unit and data format)?</a></li>
<li><a href="#array_write_spinboxes">I want to write an array value of four elements simply using spin boxes and an apply button. How to do it?</a></li>
<li><a href="#tangoprops">How do I get a Tango device property?</a></li>
<li><a href="#except">How to format a message from a Tango <em>Exception</em>?</a></li>
<li><a href="#read_request">How to trigger an asynchronous read request to the Tango engine?</a></li>
<li><a href="#migrate_log">How to migrate from QTango <em>TUtil::instance()-&gt;addLog()</em> to cumbia log dialog?</a></li>
<li><a href="#ui_h_errors">After converting a QTango project to a cumbia project, I get errors on the ui/ui_filexxx.h concerning properties of widgets that I know are defined in the cumbia widget version as well, e.g. <em>tLabel-&gt;setFalseString(..)</em></a></li>
<li><a href="#migrate_config_state_color">How to migrate QTango <em>Config::instance()-&gt;setStateColor</em> (and setStateString) to cumbia?</a></li>
<li><a href="#multiengine">How to support multiple engines (e.g. Tango and Epics) in the same application</a></li>
</ul>
<h2>Q.</h2>
<p><a class="anchor" id="newproj"></a> </p><h3>Is there a way to quickly set up a new cumbia project?</h3>
<h2>A.</h2>
<p>Yes, just execute</p>
<p><em>cumbia new project</em></p>
<p>from the command line. You will</p>
<h2>Q.</h2>
<p><a class="anchor" id="migrate"></a> </p><h3>Is there a way to migrate a QTango project into a cumbia one?</h3>
<h2>A.</h2>
<p>Yes, execute</p>
<p><em>cumbia import fast</em></p>
<p>from the command line to <em>attempt</em> the migration. Follow the instructions and carefully read the messages from the ongoing process. A little manual intervention is normally needed. It works for simple QTango projects (e.g. custom QTangoComProxyReader/QTangoComProxyWriter derived classes are not supported)</p>
<h2>Q.</h2>
<p><a class="anchor" id="cudata"></a> </p><h3>What is the default structure used to exchange data by cumbia library? How do I use it?</h3>
<h2>A.</h2>
<p>It is a class named CuData. It is a bundle pairing <em>keys</em> to <em>values</em>. <em>keys</em> are strings, while values are CuVariant objects. CuVariant is a container that can store different data types and provides convenient functions to extract data into basic types, such as double, int, unsigned, vector&lt;double&gt;, vector&lt;string&gt; and so on.</p>
<p>Example usage </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f(<span class="keyword">const</span> CuData&amp; data) {</div><div class="line">    <span class="keywordtype">double</span> d;</div><div class="line">    CuVariant v = data[<span class="stringliteral">&quot;value&quot;</span>];</div><div class="line">    d = v.toDouble();</div><div class="line">}</div></div><!-- fragment --><h2>Q.</h2>
<p><a class="anchor" id="readatt"></a> </p><h3>What is the quickest way to read a Tango attribute in a cumbia application:</h3>
<ul>
<li>blocking for the result</li>
<li>storing the result in a cumbia data structure that can be reused throughout the library</li>
<li>extracting the result/errors</li>
</ul>
<h2>A.</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cutango-world.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;tdevice.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;QDateTime&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span>(argc &lt; 3) {</div><div class="line">        printf(<span class="stringliteral">&quot;usage: %s tango/test/device  attribute_name\n\n&quot;</span>, argv[0]);</div><div class="line">        exit(EXIT_SUCCESS);</div><div class="line">    }</div><div class="line">    CuTangoWorld tw; <span class="comment">// Tango utilities to read/write attributes and command inout</span></div><div class="line">    CuData res; <span class="comment">// stores the result</span></div><div class="line">    TDevice td(argv[1]); <span class="comment">// wraps DeviceProxy creation and device connection errors</span></div><div class="line">    <span class="keywordtype">bool</span> success = td.isValid();  <span class="comment">// device defined in Tango database</span></div><div class="line">    <span class="keywordflow">if</span>(!success)</div><div class="line">        printf(<span class="stringliteral">&quot;failed to connect to device: %s: %s\n&quot;</span>, argv[1], td.getMessage().c_str());</div><div class="line">    <span class="keywordflow">else</span> {</div><div class="line">        success = tw.read_att(td.getDevice(), argv[2], res);  <span class="comment">// read attribute, store result in res, return success</span></div><div class="line">        <span class="keywordflow">if</span>(success) {</div><div class="line">            <span class="keywordtype">double</span> d = res[<span class="stringliteral">&quot;value&quot;</span>].toDouble(); <span class="comment">// extract to double (I know beforehand I am reading a double data type)</span></div><div class="line">            printf(<span class="stringliteral">&quot;value: %f [%s]\n&quot;</span>, d, qstoc(QDateTime::fromMSecsSinceEpoch(res[<span class="stringliteral">&quot;timestamp_ms&quot;</span>].toLongInt()).toString()));</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span> <span class="comment">// error reading or extracting data from the attribute</span></div><div class="line">            printf(<span class="stringliteral">&quot;failed: \&quot;%s\&quot;\n&quot;</span>, res.toString().c_str());</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h2>Q.</h2>
<p><a class="anchor" id="state"></a> </p><h3>Cool. Now, what's the quickest procedure to display a Tango <em>state</em> and possibly get the associated color?</h3>
<h2>A.</h2>
<p>Almost same code as above. Extract color from the "state_color", state string from the "value".</p>
<div class="fragment"><div class="line">success = tw.read_att(td.getDevice(), argv[2], res);  <span class="comment">// read attribute, store result in res, return success</span></div><div class="line"><span class="keywordflow">if</span>(success) {</div><div class="line">    QuPalette palette;  <span class="comment">// default color palette: maps color string to QColor</span></div><div class="line">    QColor color = palette[QString::fromStdString(res[<span class="stringliteral">&quot;state_color&quot;</span>].toString())];</div><div class="line">    Tango::DevState state = static_cast&lt;Tango::DevState&gt;(res[<span class="stringliteral">&quot;state&quot;</span>].toLongInt());</div><div class="line">    qDebug() &lt;&lt; __FUNCTION__ &lt;&lt; <span class="stringliteral">&quot;state color&quot;</span> &lt;&lt; color &lt;&lt; <span class="stringliteral">&quot;state: &quot;</span> &lt;&lt; res[<span class="stringliteral">&quot;value&quot;</span>].toString().c_str()</div><div class="line">             &lt;&lt; <span class="stringliteral">&quot;as DevState: &quot;</span> &lt;&lt; state;</div><div class="line">}</div></div><!-- fragment --> <h2>Q.</h2>
<p><a class="anchor" id="cudata_keys"></a> </p><h3>How did you know that the <em>res</em> CuData contained those very keys such as "value", "state_color", "timestamp_ms", and so on.. ?</h3>
<h2>A.</h2>
<p>There are two ways of knowing what CuData contains. The first is the most universal one, the second is handy when dealing with Tango specific data.</p>
<ul>
<li>simply print the output of CuData::toString() to have a representation of the internal data</li>
<li>visit the <a href="../../cumbia-tango/html/cudata_for_tango.html">CuData bundle description for data exchange with the Tango world</a> documentation page.</li>
</ul>
<p>The example</p>
<div class="fragment"><div class="line">success = tw.read_att(td.getDevice(), argv[2], res);</div><div class="line"><span class="keywordflow">if</span>(success) {</div><div class="line">    std::cout &lt;&lt; res.toString() &lt;&lt; std::endl;</div></div><!-- fragment --><p>executed on TangoTest device/double_scalar attribute, produces an output like this:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Output   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CuData { ["data_format_str" -&gt; scalar], ["err" -&gt; false], ["mode" -&gt; ], ["msg" -&gt; : Mon Dec 10 15:13:15 2018], ["quality" -&gt; 0], ["quality_color" -&gt; white], ["success_color" -&gt; dark_green], ["timestamp_ms" -&gt; 1544451195642], ["timestamp_us" -&gt; 1544451195.642567], ["value" -&gt; 0.342020], ["w_value" -&gt; 1.000000] } (size: 11 isEmpty: 0)   </td></tr>
</table>
<p>from which you can infer that a code like the following can work:</p>
<div class="fragment"><div class="line">success = tw.read_att(td.getDevice(), argv[2], res);</div><div class="line"><span class="keywordtype">bool</span> error = res[<span class="stringliteral">&quot;err&quot;</span>].toBool();</div><div class="line"><span class="keywordflow">if</span>(!error) {</div><div class="line">    <span class="keywordtype">double</span> read_val = res[<span class="stringliteral">&quot;value&quot;</span>].toDouble();</div><div class="line">    <span class="keywordtype">double</span> write_val = res[<span class="stringliteral">&quot;w_value&quot;</span>].toDouble(); <span class="comment">// if Tango attribute is read/write</span></div><div class="line">    std::string message = res[<span class="stringliteral">&quot;msg&quot;</span>].toString();</div><div class="line">}</div></div><!-- fragment --><h2>Q. How to quickly convert std::vector/std::string-based data in CuData to more Qt friendly QVector/QStringList/QStringList ?</h2>
<p><a class="anchor" id="stdvector_string_to_qvector_qstringlist"></a></p>
<h2>A.</h2>
<p>Normally, you should use QString::fromStdString and cycle through std::vector&lt;std::string&gt; to append elements to a QStringList. The same goes for std::vector, requiring QVector::fromStdVector.</p>
<p>The <em>cumbia-qtcontrols</em> module helps providing three classes that extremely reduce the needed code. Have a look at QuString, QuStringList and QuVector classes documentation. They are rich in examples and you will be pleased by how easy the conversion from standard c++ library vectors and strings to Qt counterparts is made.</p>
<p>See the following code snippets to see how necessary code shrinks as soon as you employ QuStringList</p>
<p>#### Sample code 1: without QuStringList (example taken from <em>cumbia-qtcontrols --&gt; qulabel.cpp, function QuLabel::m_configure</em>) </p><div class="fragment"><div class="line">QColor c;</div><div class="line">QString s;</div><div class="line">std::vector&lt;std::string&gt; colors, labels;</div><div class="line">colors = da[<span class="stringliteral">&quot;colors&quot;</span>].toStringVector();</div><div class="line">labels = da[<span class="stringliteral">&quot;values&quot;</span>].toStringVector();</div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; qMax(colors.size(), labels.size()); i++) {</div><div class="line">    setEnumDisplay(static_cast&lt;int&gt;(i), i &lt; labels.size() ? QString::fromStdString(labels[i]) : <span class="stringliteral">&quot;-&quot;</span>,</div><div class="line">                   i &lt; colors.size() ? c = d-&gt;palette[QString::fromStdString(colors[i])] : c = QColor(Qt::white));</div><div class="line">}</div></div><!-- fragment --><p>#### Sample code 2: exploiting QuStringList (same source file as above) </p><div class="fragment"><div class="line">QColor c;</div><div class="line">QString s;</div><div class="line"><span class="comment">// colors and labels will be empty if &quot;colors&quot; and &quot;labels&quot; are not found</span></div><div class="line">QuStringList colors(da, <span class="stringliteral">&quot;colors&quot;</span>), labels(da, <span class="stringliteral">&quot;values&quot;</span>);</div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; qMax(colors.size(), labels.size()); i++) {</div><div class="line">      setEnumDisplay(i, i &lt; labels.size() ? labels[i] : <span class="stringliteral">&quot;-&quot;</span>,  i &lt; colors.size() ? c = d-&gt;palette[colors[i]] : c = QColor(Qt::white));</div><div class="line">}</div></div><!-- fragment --><p>Much more concise, right?</p>
<p>#### Sample code 3: without using QuVector </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> Writer::vDataReady(<span class="keyword">const</span> CuData &amp;v) {</div><div class="line">    QVector&lt;double&gt; readData = QVector&lt;double&gt;::fromStdVector( v[<span class="stringliteral">&quot;value&quot;</span>].toDoubleVector())</div><div class="line">    <span class="comment">// ...</span></div><div class="line">}</div></div><!-- fragment --><h4>Sample code 4: using QuVector</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Writer::vDataReady(<span class="keyword">const</span> CuData &amp;v)</div><div class="line"> {</div><div class="line">     <span class="comment">// if v.containsKey(&quot;value&quot;) and v[&quot;value&quot;] is a vector</span></div><div class="line">     <span class="comment">// qv will contain v[&quot;value&quot;] converted to QVector</span></div><div class="line">     QVector&lt;double&gt; qv = QuVector&lt;double&gt;(v);</div><div class="line">}</div></div><!-- fragment --><p> As you can see from the piece of code above, QuVector <em>is</em> a QVector and so the former can be directly assigned to the latter.</p>
<p>Please refer to the specific documentation for more details.</p>
<h2>Q.</h2>
<p><a class="anchor" id="commands"></a> </p><h3>I want a quick way to perform a command inout on a device now, thanks.</h3>
<h2>A.</h2>
<p>Two possible scenarios are possible, dude:</p>
<h4>1. You know in advance the output data type and you can provide the input value by code. A full working example follows:</h4>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cutango-world.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;tdevice.h&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span>(argc &lt; 4) {</div><div class="line">        printf(<span class="stringliteral">&quot;usage: %s tango/test/device command input_1\n\n&quot;</span>, argv[0]);</div><div class="line">        exit(EXIT_SUCCESS);</div><div class="line">    }</div><div class="line">    CuTangoWorld tw;</div><div class="line">    CuData res;</div><div class="line">    TDevice td(argv[1]);</div><div class="line">    <span class="keywordflow">if</span>(!td.isValid())</div><div class="line">         std::cerr &lt;&lt; <span class="stringliteral">&quot;failed to connect to device: &quot;</span> &lt;&lt; argv[1] &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; td.getMessage() &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">else</span> {</div><div class="line">        res[<span class="stringliteral">&quot;argins&quot;</span>]  = std::string(argv[3]);                   <span class="comment">// input value</span></div><div class="line">        res[<span class="stringliteral">&quot;in_type&quot;</span>] = Tango::DEV_DOUBLE;      <span class="comment">// input data type</span></div><div class="line">        success = tw.cmd_inout(td.getDevice(), argv[2], res);</div><div class="line">        std::cout &lt;&lt; res[<span class="stringliteral">&quot;value&quot;</span>].toDouble() &lt;&lt; <span class="stringliteral">&quot;  [&quot;</span> &lt;&lt; res.toString() &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><ul>
<li>Test with: ./doctest test/device/1 DevDouble 10.011</li>
</ul>
<p>Please note: command and input must be compatible (DEV_DOUBLE has been forced in "in_type" by code)</p>
<h4>2. You want to provide a generic input to a command and want it to be converted to the right type at runtime. Look at this:</h4>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cutango-world.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;tdevice.h&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span>(argc &lt; 4) {</div><div class="line">        printf(<span class="stringliteral">&quot;usage: %s tango/test/device  command input_arg1 input_arg2 ... input_argN\n\n&quot;</span>, argv[0]);</div><div class="line">        exit(EXIT_SUCCESS);</div><div class="line">    }</div><div class="line">    CuTangoWorld tw;</div><div class="line">    CuData res;</div><div class="line">    TDevice td(argv[1]);</div><div class="line">    <span class="keywordtype">bool</span> success = td.isValid();</div><div class="line">    <span class="keywordflow">if</span>(!success)</div><div class="line">         std::cerr &lt;&lt; <span class="stringliteral">&quot;failed to connect to device: &quot;</span> &lt;&lt; argv[1] &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; td.getMessage() &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">else</span> {</div><div class="line">        std::vector&lt;std::string&gt; argins;                                <span class="comment">// arbitrary number of argins in this example</span></div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 3; i &lt; argc; i++)</div><div class="line">            argins.push_back(std::string(argv[i]));</div><div class="line">        res[<span class="stringliteral">&quot;argins&quot;</span>] = argins;                                         <span class="comment">// store input args in the &quot;argins&quot; key</span></div><div class="line">        success = tw.get_command_info(td.getDevice(), argv[2], res);    <span class="comment">// we need this _additional_ call to interpret</span></div><div class="line">        <span class="keywordflow">if</span>(success)                                                     <span class="comment">// input arguments</span></div><div class="line">            success = tw.cmd_inout(td.getDevice(), argv[2], res);       <span class="comment">// get output from command</span></div><div class="line">        std::cout &lt;&lt; res.toString() &lt;&lt; std::endl;                       <span class="comment">// print result</span></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>This example is much more flexible:</p>
<ul>
<li>Test with *./doctest test/device/1 DevVarDoubleArray 1 1.2 1.3*</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Output   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CuData { ["argins" -&gt; 1,1.2,1.3], ["cmd_name" -&gt; DevVarDoubleArray], ["data_format" -&gt; 1], ["data_format_str" -&gt; vector], ["data_type" -&gt; 13], ["display_level" -&gt; 0], ["err" -&gt; false], ["in_type" -&gt; 13], ["in_type_desc" -&gt; -], ["mode" -&gt; ], ["msg" -&gt; : Mon Dec 10 16:12:43 2018[vector]], ["out_type" -&gt; 13], ["out_type_desc" -&gt; -], ["timestamp_ms" -&gt; 1544454763108], ["timestamp_us" -&gt; 1544454763.108265], ["type" -&gt; property], ["value" -&gt; 1.000000,1.200000,1.300000] } (size: 17 isEmpty: 0)   </td></tr>
</table>
<ul>
<li>Test with *./doctest test/device/1 DevString "foo bar"*</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Output   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CuData { ["argins" -&gt; foo bar], ["cmd_name" -&gt; DevString], ["data_format" -&gt; 0], ["data_format_str" -&gt; scalar], ["data_type" -&gt; 8], ["display_level" -&gt; 0], ["err" -&gt; false], ["in_type" -&gt; 8], ["in_type_desc" -&gt; -], ["mode" -&gt; ], ["msg" -&gt; : Mon Dec 10 16:13:35 2018[scalar]], ["out_type" -&gt; 8], ["out_type_desc" -&gt; -], ["timestamp_ms" -&gt; 1544454815747], ["timestamp_us" -&gt; 1544454815.747049], ["type" -&gt; property], ["value" -&gt; foo bar] } (size: 17 isEmpty: 0)   </td></tr>
</table>
<h2>Q.</h2>
<p><a class="anchor" id="cumbiawidget"></a> </p><h3>In QTango there used to be a widget ready to read and display a value. In cumbia there is not. How do I quickly adapt an existing Qt widget?</h3>
<h2>A.</h2>
<h4>1. The longest <em>reusable</em> way</h4>
<p>Extend the Qt widget apt to display the desired data and implement CuDataListener interface. See <a href="../../qumbianewcontrolwizard/html/tutorial_qumbianewcontrolwizard.html">Quickly add a Qt widget to your cumbia project</a> documentation. Within the <em>onUpdate(const CuData&amp; data)</em> method you will receive two kinds of updates:</p><ul>
<li>if data["type"].toString() == "property" it's a <em>configuration</em> update (from the Tango database)</li>
<li>if data.containsKey("value") you can extract the new value from <em>data</em>.</li>
</ul>
<h4>2. The quickest way (what you asked, indeed)</h4>
<p>Use a <a href="../../cumbia-qtcontrols/html/classQuWatcher.html">QuWatcher</a> to monitor a Tango attribute or command, choosing among the many available signals compatible with the adopted widget. In this example, we follow the <em>most generic and flexible</em> approach, to benefit from all the details available from the update. Thus, we will use the</p>
<p><em>void newData(const CuData &amp;data)</em> signal from QuWatcher</p>
<p>The QTango implementation adopted a TTextBrowser to read a Tango <em>DevVarStringArray</em> and display a dotted list on the text area. We will employ QTextEdit (object name "textEdit" in *.ui* file) plus QuWatcher to accomplish the same result.</p>
<p>Edit the main widget <em>cpp</em> file, add the needed include file and modify the class constructor</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;quwatcher.h&gt;</span></div><div class="line"></div><div class="line">mywidget::mywidget(CumbiaTango *cut, QWidget *parent) : QWidget(parent)</div><div class="line">{</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    ui-&gt;setupUi(<span class="keyword">this</span>, cu_t, cu_tango_r_fac, cu_tango_w_fac);</div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    QuWatcher *quW = <span class="keyword">new</span> QuWatcher(<span class="keyword">this</span>, cut, cu_tango_r_fac);</div><div class="line">    connect(quW, SIGNAL(newData(<span class="keyword">const</span> CuData&amp;)), <span class="keyword">this</span>, SLOT(onNewReport(<span class="keyword">const</span> CuData&amp;)));</div><div class="line">    quW-&gt;setSource(<span class="stringliteral">&quot;$1-&gt;GetReport&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p>A <em>Qt SLOT onNewReport()</em> must be introduced to update the text (heaeder file declaration omitted):</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> mywidget::onNewReport(<span class="keyword">const</span> CuData &amp;da)</div><div class="line">{</div><div class="line">    QString html;</div><div class="line">    ui-&gt;textEdit-&gt;setDisabled(da[<span class="stringliteral">&quot;err&quot;</span>].toBool());</div><div class="line">    ui-&gt;textEdit-&gt;setToolTip(QString::fromStdString(da[<span class="stringliteral">&quot;msg&quot;</span>].toString()));</div><div class="line">    <span class="keywordflow">if</span>(ui-&gt;textEdit-&gt;isEnabled()) {                                  <span class="comment">// read successful</span></div><div class="line">        std::vector&lt;std::string&gt; vs = da[<span class="stringliteral">&quot;value&quot;</span>].toStringVector();  <span class="comment">// DevVarStringArray to vector&lt;string&gt;</span></div><div class="line">        <span class="keywordflow">foreach</span>(<span class="keyword">const</span> std::string &amp;s, vs) {</div><div class="line">            html += <span class="stringliteral">&quot;&lt;li&gt;&quot;</span> + QString::fromStdString(s) + <span class="stringliteral">&quot;&lt;/li&gt;\n&quot;</span>;  <span class="comment">// add list element</span></div><div class="line">        }</div><div class="line">        ui-&gt;textEdit-&gt;setHtml(<span class="stringliteral">&quot;&lt;ul&gt;&quot;</span> + html + <span class="stringliteral">&quot;&lt;/ul&gt;&quot;</span>);    <span class="comment">// wrap &lt;li&gt; into an unordered list (bullet list)</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> {     <span class="comment">// read failed</span></div><div class="line">        ui-&gt;textEdit-&gt;setHtml(ui-&gt;textEdit-&gt;toolTip());</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h2>Q.</h2>
<p><a class="anchor" id="cumbiawidget_props"></a> </p><h3>How do I fetch specific Tango attribute properties to configure my custom cumbia widget?</h3>
<h2>A.</h2>
<p>Before setting the source, the CuContext must be informed of the desired properties to fetch at configuration time. An example implementation is represented by QuLabel, in cumbia-qtcontrols module. First of all, define a vector of strings with the list of the properties. Then encapsulate it into a CuData <em>key</em> named <em>fetch_props</em>. Remember that this <em>key</em> may be understood only by some engines. <em>cumbia-tango</em> is one of them. Let's write a private <em>m_initCtx</em> that sets up the link with the desired properties to retrieve:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyWidget::m_initCtx(CuContext *ctx) {</div><div class="line">    std::vector&lt;std::string&gt; props;</div><div class="line">    props.push_back(<span class="stringliteral">&quot;labels&quot;</span>);</div><div class="line">    d-&gt;context-&gt;setOptions(CuData(<span class="stringliteral">&quot;fetch_props&quot;</span>, props));</div><div class="line">}</div></div><!-- fragment --><p>When the client of your widget activates the link with <em>setSource</em>, you will start receiving updates within the <em>onUpdate</em> method. Therein, look for the data with the <em>key</em> <b>type</b> set to <em>property</em>, as usual. If the property names specified in the m_initCtx method exist, you will receive their values in the data bundle:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyWidget::onUpdate(<span class="keyword">const</span> CuData &amp;da) {</div><div class="line">  <span class="keywordflow">if</span>(!da[<span class="stringliteral">&quot;err&quot;</span>].toBool()  &amp;&amp; da[<span class="stringliteral">&quot;type&quot;</span>].toString() == <span class="stringliteral">&quot;property&quot;</span>) {</div><div class="line">      <span class="comment">// ... configuration</span></div><div class="line">      <span class="comment">// use properties to configure mywidget</span></div><div class="line">      <span class="keywordflow">if</span>(da.containsKey(<span class="stringliteral">&quot;labels&quot;</span>)) {</div><div class="line">        std::vector&lt;std::string&gt; labels = da[<span class="stringliteral">&quot;labels&quot;</span>].toStringVector();</div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; labels.size(); i++)</div><div class="line">          ; <span class="comment">// use labels</span></div><div class="line">      }</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>In the above code snippet you can see how the custom widget can be configured automatically through appropriate Tango attribute properties. See the QuLabel code in cumbia-qtcontrols for a working example.</p>
<h2>Q.</h2>
<p><a class="anchor" id="configure"></a> </p><h3>I either used QuWatcher or implemented CuDataListener on my custom graphical object. How do I configure it through the Tango database properties (setting maximum and minimum values, display unit and data format)?</h3>
<h2>A.</h2>
<p>Just look for the CuData with the <em>type</em> key set to the <em>property</em> string. That's the bundle containing the Tango database configuration.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyCustomWidget::onUpdate(<span class="keyword">const</span> CuData &amp;da)</div><div class="line">{</div><div class="line">    <span class="keywordtype">bool</span> is_config = da[<span class="stringliteral">&quot;type&quot;</span>].toString() == std::string(<span class="stringliteral">&quot;property&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span>(is_config) {</div><div class="line">        CuVariant m = da[<span class="stringliteral">&quot;min&quot;</span>], M = da[<span class="stringliteral">&quot;max&quot;</span>];</div><div class="line">        std::string print_format = da[<span class="stringliteral">&quot;format&quot;</span>].toString();</div><div class="line">        <span class="keywordtype">double</span> min, max;</div><div class="line">        <span class="keywordtype">bool</span> ok;</div><div class="line">        ok = m.to&lt;<span class="keywordtype">double</span>&gt;(min);     <span class="comment">// try to convert min</span></div><div class="line">        <span class="keywordflow">if</span>(ok)                      <span class="comment">// try to convert max if min succeeded</span></div><div class="line">            ok = M.to&lt;<span class="keywordtype">double</span>&gt;(max);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span>(ok) {  <span class="comment">// very good: Range properly configured in Tango database</span></div><div class="line">            setMinimum(min);  <span class="comment">// set minimum value on MyCustomWidget</span></div><div class="line">            setMaximum(max);  <span class="comment">// set maximum value on MyCustomWidget</span></div><div class="line">        }</div></div><!-- fragment --><h2>Q.</h2>
<p><a class="anchor" id="tarray_write_spinboxes"></a></p>
<h3>I want to write an array value of four elements simply using spin boxes and an apply button. How to do it?</h3>
<h3>A.</h3>
<h2>Q.</h2>
<p><a class="anchor" id="tangoprops"></a> </p><h3>How do I get a Tango device property?</h3>
<h2>A.</h2>
<h4>1. The quick way (in current thread)</h4>
<p>Build a list of CuData containing the desired property names and types, as shown in the code below. Then use the CuTangoWorld utility class to get the properties and finally extract them from the results.</p>
<div class="fragment"><div class="line">CuTangoWorld tw;</div><div class="line">CuData res;</div><div class="line">std::vector&lt;CuData&gt; in_data;</div><div class="line"><span class="comment">// 1. build input data with the desired property names</span></div><div class="line"><span class="comment">// device property</span></div><div class="line">CuData devpd(<span class="stringliteral">&quot;device&quot;</span>, <span class="stringliteral">&quot;test/device/1&quot;</span>);</div><div class="line">devpd[<span class="stringliteral">&quot;name&quot;</span>] = <span class="stringliteral">&quot;description&quot;</span>;</div><div class="line">in_data.push_back(devpd);</div><div class="line"><span class="comment">// attribute property values from the &quot;double_scalar&quot; attribute</span></div><div class="line">CuData apd(<span class="stringliteral">&quot;device&quot;</span>, <span class="stringliteral">&quot;test/device/2&quot;</span>);</div><div class="line">apd[<span class="stringliteral">&quot;attribute&quot;</span>] = <span class="stringliteral">&quot;double_scalar&quot;</span>;</div><div class="line">apd[<span class="stringliteral">&quot;name&quot;</span>] = <span class="stringliteral">&quot;values&quot;</span>;</div><div class="line">in_data.push_back(apd);</div><div class="line"><span class="comment">// class property</span></div><div class="line">CuData cld(<span class="stringliteral">&quot;class&quot;</span>, <span class="stringliteral">&quot;TangoTest&quot;</span>);</div><div class="line">cld[<span class="stringliteral">&quot;name&quot;</span>] = <span class="stringliteral">&quot;ProjectTitle&quot;</span>;</div><div class="line">in_data.push_back(cld);</div><div class="line"><span class="comment">// 2. get the properties</span></div><div class="line">tw.get_properties(in_data, res);</div><div class="line"><span class="comment">// 3. extract  and print results</span></div><div class="line"><span class="keywordflow">if</span>(data[<span class="stringliteral">&quot;err&quot;</span>].toBool())</div><div class="line">    printf(<span class="stringliteral">&quot;error fetching properties: %s\n&quot;</span>, data[<span class="stringliteral">&quot;msg&quot;</span>].toString().c_str());</div><div class="line"><span class="keywordflow">else</span> {</div><div class="line">        printf(PROPERTY|\t\t\t--&gt;|VALUES<span class="stringliteral">&quot;);</span></div><div class="line"><span class="stringliteral">        std::vector&lt;std::string&gt; plist = data[&quot;</span>list<span class="stringliteral">&quot;].toStringVector();</span></div><div class="line"><span class="stringliteral">        for(size_t i = 0; i &lt; plist.size(); i++)</span></div><div class="line"><span class="stringliteral">            printf(&quot;</span>%s--&gt;%s\n<span class="stringliteral">&quot;, plist[i].c_str(), data[plist[i]].toString().c_str());</span></div><div class="line"><span class="stringliteral">    }</span></div></div><!-- fragment --><h4>2. The <em>activity</em> approach (in secondary thread)</h4>
<ul>
<li>Define a class inheriting from CuDataListener and implement the onUpdate(const CuData&amp;) virtual method where results will be delivered. The construction of the input data list is the same as in the example (1). The extraction of the results is identical too.</li>
</ul>
<p>#### The header file </p><div class="fragment"><div class="line"><span class="keyword">class </span>PropertyReader : <span class="keyword">public</span> CuDataListener</div><div class="line">{</div><div class="line">     <span class="comment">// ...</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// CuDataListener interface</span></div><div class="line">    <span class="keywordtype">void</span> onUpdate(<span class="keyword">const</span> CuData &amp;data);</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    CumbiaTango* m_ct;</div></div><!-- fragment --><h4>The implementation file</h4>
<p>We use the CuTDbPropertyReader class to fetch the properties and receive the data when ready.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> PropertyReader::get(...) {</div><div class="line">    <span class="comment">// CuTDbPropertyReader needs a const char* as id as first parameter and a</span></div><div class="line">    <span class="comment">// pointer to CumbiaTango as second parameter</span></div><div class="line">    CuTDbPropertyReader *pr = <span class="keyword">new</span> CuTDbPropertyReader(<span class="stringliteral">&quot;myPropertyReader&quot;</span>, m_ct);</div><div class="line">    pr-&gt;addListener(<span class="keyword">this</span>);  <span class="comment">// we implement CuDataListener</span></div><div class="line">    pr-&gt;get(in_data);       <span class="comment">// request properties</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> PropertyReader::onUpdate(<span class="keyword">const</span> CuData &amp;data)</div><div class="line">{</div><div class="line">    <span class="comment">// see the point (3) of the *quick way* example above to extract  and print results</span></div><div class="line">}</div></div><!-- fragment --><h4>Example code</h4>
<p>You can find a working command line example under</p>
<ul>
<li><em>cumbia-libs/cumbia-tango/examples/dbproperties</em></li>
</ul>
<h2>Q.</h2>
<p><a class="anchor" id="except"></a> </p><h3>How to format a message from a Tango <em>Exception</em>?</h3>
<h2>A.</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include&lt;cutango-world.h&gt;</span></div><div class="line"><span class="keywordflow">try</span> {</div><div class="line">    <span class="comment">// ...</span></div><div class="line">}</div><div class="line"><span class="keywordflow">catch</span>(Tango::DevFailed &amp;e)</div><div class="line">{</div><div class="line">    CuTangoWorld tw;</div><div class="line">    std::string serr = tw.strerror(e);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="read_request"></a> </p><h3>How to trigger an asynchronous read request to the Tango engine?</h3>
<p>An explicit <em>read request</em> can be sent to the Tango engine only when the <em>refresh mode is either polled or manual</em>. In the following example the read operation is sent through a <em>QuLabel</em>'s <em>CuContext</em>; it is possible to do the same with any other reader through its <em>context</em>. Please note that there are two control widgets connected to the same source (<em>QuLabel and QuCircularGauge</em>): they share the same refresh mode. The <em>refresh button</em> updates both, but it is not possible to configure different modes for the same source because they share the same link.</p>
<div class="fragment"><div class="line"><span class="comment">// cumbia-tango</span></div><div class="line"><span class="preprocessor">#include &lt;cuserviceprovider.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cumacros.h&gt;</span></div><div class="line"><span class="comment">// cumbia-tango</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cucontext.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;qulabel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cutreader.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;qucirculargauge.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;QPushButton&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;QVBoxLayout&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;QApplication&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;QLabel&gt;</span></div><div class="line"></div><div class="line">Manual_refresh::Manual_refresh(CumbiaTango *cut, QWidget *parent) :</div><div class="line">    QWidget(parent)</div><div class="line">{</div><div class="line">   <span class="comment">// cumbia-tango</span></div><div class="line">    cu_t = cut;</div><div class="line">    m_log = <span class="keyword">new</span> CuLog(&amp;m_log_impl);</div><div class="line">    cu_t-&gt;getServiceProvider()-&gt;registerService(CuServices::Log, m_log);</div><div class="line">    <span class="comment">// cumbia-tango</span></div><div class="line"></div><div class="line">  QVBoxLayout *vlo = <span class="keyword">new</span> QVBoxLayout(<span class="keyword">this</span>);</div><div class="line">  QLabel *title = <span class="keyword">new</span> QLabel(<span class="stringliteral">&quot;Manual Refresh Mode Example&quot;</span>, <span class="keyword">this</span>);</div><div class="line">  QLabel *src = <span class="keyword">new</span> QLabel(<span class="keyword">this</span>);</div><div class="line">  QuLabel *l = <span class="keyword">new</span> QuLabel(<span class="keyword">this</span>, cu_t, cu_tango_r_fac);</div><div class="line">  QuCircularGauge *g = <span class="keyword">new</span> QuCircularGauge(<span class="keyword">this</span>, cu_t, cu_tango_r_fac);</div><div class="line">  QPushButton *b = <span class="keyword">new</span> QPushButton(<span class="stringliteral">&quot;Click to Refresh!&quot;</span>, <span class="keyword">this</span>);</div><div class="line"></div><div class="line">  <span class="comment">// vertically fixed size for labels</span></div><div class="line">  <span class="keywordflow">foreach</span>(QWidget *w, QList&lt;QWidget *&gt;()&lt;&lt;l &lt;&lt; title &lt;&lt; src)</div><div class="line">    w-&gt;setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Fixed);</div><div class="line"></div><div class="line">  <span class="comment">// configure sources!</span></div><div class="line">  <span class="keywordflow">if</span>(qApp-&gt;arguments().size() &gt; 1) {</div><div class="line">      l-&gt;getContext()-&gt;setOptions(CuData(<span class="stringliteral">&quot;refresh_mode&quot;</span>, CuTReader::Manual));</div><div class="line">      l-&gt;setSource(qApp-&gt;arguments().at(1));</div><div class="line">      g-&gt;setSource(l-&gt;source());</div><div class="line">      src-&gt;setText(l-&gt;source());</div><div class="line">  } <span class="comment">// else: usage: ...</span></div><div class="line"></div><div class="line">  <span class="keywordflow">foreach</span>(QWidget *w, QList&lt;QWidget *&gt;() &lt;&lt; title &lt;&lt; src &lt;&lt; l &lt;&lt; g &lt;&lt; b)</div><div class="line">    vlo-&gt;addWidget(w);</div><div class="line"></div><div class="line">  connect(b, SIGNAL(clicked()), <span class="keyword">this</span>, SLOT(read()));</div><div class="line">  resize(300, 400);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// slot: request a read operation</span></div><div class="line"><span class="keywordtype">void</span> Manual_refresh::read()</div><div class="line">{</div><div class="line">    QuLabel *l = findChild&lt;QuLabel *&gt;();</div><div class="line">    l-&gt;getContext()-&gt;sendData(CuData(<span class="stringliteral">&quot;read&quot;</span>, <span class="stringliteral">&quot;&quot;</span>));</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="migrate_log"></a> </p><h3>How to migrate from QTango <em>TUtil::instance()-&gt;addLog()</em> to <em>cumbia</em> log dialog?</h3>
<h2>A.</h2>
<p>QTango:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include&lt;TLog&gt;</span></div><div class="line"><span class="preprocessor">#include&lt;TUtil&gt;</span></div><div class="line"><span class="comment">// ...</span></div><div class="line">} <span class="keywordflow">catch</span> (Tango::DevFailed &amp;e) {</div><div class="line">    TLog log(e);</div><div class="line">    TUtil::instance()-&gt;addLog(log);</div><div class="line">}</div></div><!-- fragment --><p>cumbia</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;qulogimpl.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cumbiatango.h&gt;</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="comment">// 1. header file: class definition</span></div><div class="line"><span class="keyword">class </span>MyClass : <span class="keyword">public</span> QWidget</div><div class="line">{</div><div class="line">    Q_OBJECT</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">//...</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    CumbiaTango *cumbia_t;</div><div class="line">    QuLogImpl m_log_impl;  <span class="comment">// cumbia-qtcontrols log implementation</span></div><div class="line">    CuLog *m_log;          <span class="comment">// cumbia service, implements CuServiceI (cumbia/src/lib/services)</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// 2. cpp file</span></div><div class="line"><span class="preprocessor">#include &lt;cutango-world.h&gt;</span></div><div class="line"></div><div class="line">MyClass::MyClass(...) {</div><div class="line">    <span class="comment">// cumbia_t = ...</span></div><div class="line">    m_log = <span class="keyword">new</span> CuLog(&amp;m_log_impl);</div><div class="line">    cumbia_t-&gt;getServiceProvider()-&gt;registerService(CuServices::Log, m_log);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// manage exception and add message to log</span></div><div class="line"><span class="comment">//</span></div><div class="line">} <span class="keywordflow">catch</span> (Tango::DevFailed &amp;e) {</div><div class="line">    CuTangoWorld tw;</div><div class="line">    std::string err = tw.strerror(e);</div><div class="line">    m_log-&gt;write(<span class="stringliteral">&quot;Dual&quot;</span>, err);</div><div class="line">    m_log_impl.getDialog()-&gt;show(); <span class="comment">// to show the dialog</span></div><div class="line">}</div></div><!-- fragment --><p>Please note that if you either migrate from a QTango project (<em>cumbia import [fast]</em>) or generate a new cumbia project (<em>cumbia new project</em>), most of the code needed to manage log messages is already written for you. The reason why more code is needed to <em>initialize</em> the log system is that cumbia does not resort to <em>singleton patterns</em> and the log model is more flexible: alternative implementations can be provided.</p>
<h2>Q.</h2>
<p><a class="anchor" id="ui_h_errors"></a> </p><h3>After converting a QTango project to a cumbia project, I get errors on the ui/ui_filexxx.h concerning properties of widgets that I know are defined in the cumbia widget version as well, e.g. <em>tLabel-&gt;setFalseString(..)</em></h3>
<h2>A.</h2>
<p>Open the <em>ui</em> file with the Qt designer and save it again, overwriting it. Then try rebuilding.</p>
<h2>Q.</h2>
<p><a class="anchor" id="migrate_config_state_color"></a> </p><h3>How to migrate QTango <em>Config::instance()-&gt;setStateColor</em> (and <em>setStateString</em>) to cumbia?</h3>
<h2>A.</h2>
<p>There is no such singleton thing as QTango <em>Config::instance</em> in cumbia. Moreover, QuLabel, QuLed and other display widgets part of <em>cumbia-qtcontrols</em> must be unaware of the kind of engine in use. QuLed and QuLabel access the <em>state_color</em> key in the CuVariant data, if present. It is a simple string describing the color to use, such as "red", "green", "white"... That color description is used to fetch the actual QColor from the internal <em>QuPalette</em> used by suitable display widgets. What you can do is alter the QuPalette so that a different QColor is picked for a given color name. That operation is no more a global configuration; it must be applied to the individual widgets.</p>
<p>### Old code </p><div class="fragment"><div class="line">Config::instance()-&gt;setStateColor(Tango::OPEN, EColor(Elettra::green));</div><div class="line">Config::instance()-&gt;setStateColor(Tango::CLOSE, EColor(Elettra::darkYellow));</div></div><!-- fragment --><p>These changes used to affect <em>all widgets representing a state</em> in the application.</p>
<h3>New code</h3>
<p>Open the <em>ui</em> file and find the widget used to display the state. Suppose it is a QuLabel with name <em>tState</em>. From the CuTangoWorldConfig documentation, one can see the following association between states and color:</p>
<ul>
<li>[Tango::CLOSE] = "white1";</li>
<li>[Tango::OPEN] = "white2";</li>
</ul>
<p>We have to replace the white colors with the desired ones. Open the <em>cpp</em> file and change the QuPalette of the QuLabel:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;qupalette.h&gt;</span></div><div class="line">QuPalette pa = ui-&gt;tState-&gt;quPalette();</div><div class="line">pa[<span class="stringliteral">&quot;white1&quot;</span>] = QColor(Qt::darkYellow);</div><div class="line">pa[<span class="stringliteral">&quot;white2&quot;</span>] = QColor(Qt::green);</div><div class="line">ui-&gt;tState-&gt;setQuPalette(pa);</div></div><!-- fragment --><p> At the moment of writing this documentation, there is no convenient way to map the default text associated to a Tango state to a custom one.</p>
<h2>Q.</h2>
<p><a class="anchor" id="multiengine"></a> </p><h3>How to support multiple engines (e.g. Tango and Epics) in the same application?</h3>
<h2>A.</h2>
<p>The application will make use of the <a href="../../cumbia/html/classCumbiaPool.html">CumbiaPool</a> class, in combination with CuControlsFactoryPool. Refer to the <a href="../../cumbia/html/classCumbiaPool.html">CumbiaPool</a> documentation, that provides an example. If the <em>cumbia pool</em> is configured with appropriate <em>source patterns</em>, the application should recognise the engine each source belongs to. For example, if the <em>patterns</em> for a Tango source are *".+/.+"* and *".+-&gt;.+"* (as <em>regular expressions</em>) and the <em>patterns</em> for an EPICS source include *".+:.+"*, then a source like <em>sys/tg_test/1/double_scalar</em> will be interpreted as a Tango source, while <em>motor:ai1</em> will be linked to the EPICS engine. The <a href="../../cumbia-tango/html/classCuTangoWorld.html">CuTangoWorld</a> and <a href="../../cumbia-epics/html/classCuEpicsWorld.html">CuEpicsWorld</a> provide lists of <em>default source patterns</em>. Please note that the "epics" and "tango" strings passed to registerCumbiaImpl, registerImpl and setSrcPatterns must match for each engine respectively. Those names link together the associated engines.</p>
<p>The <em>cumbia new project</em> tool will let you automatically create a skeleton project able to manage multiple engines.</p>
<p>A cumbia application with multiple engine support will generally contain the following initialization code:</p>
<div class="fragment"><div class="line">QumbiaClient::QumbiaClient(CumbiaPool *cumbia_pool, QWidget *parent) :</div><div class="line">    QWidget(parent),</div><div class="line">    <span class="comment">// ...</span></div><div class="line">{</div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    <span class="comment">// setup Cumbia pool and register cumbia implementations for tango and epics</span></div><div class="line"><span class="preprocessor">#ifdef QUMBIA_EPICS_CONTROLS</span></div><div class="line">    CumbiaEpics* cuep = <span class="keyword">new</span> CumbiaEpics(<span class="keyword">new</span> CuThreadFactoryImpl(), <span class="keyword">new</span> QThreadsEventBridgeFactory());</div><div class="line">    cu_pool-&gt;registerCumbiaImpl(<span class="stringliteral">&quot;epics&quot;</span>, cuep);</div><div class="line">    <span class="comment">// m_ctrl_factory_pool  is in this example a private member of type CuControlsFactoryPool</span></div><div class="line">    m_ctrl_factory_pool.registerImpl(<span class="stringliteral">&quot;epics&quot;</span>, CuEpReaderFactory());   <span class="comment">// register EPICS reader implementation</span></div><div class="line">    m_ctrl_factory_pool.registerImpl(<span class="stringliteral">&quot;epics&quot;</span>, CuEpWriterFactory());   <span class="comment">// register EPICS writer implementation</span></div><div class="line"></div><div class="line">    CuEpicsWorld ew;  <span class="comment">// EPICS cumbia helper class</span></div><div class="line">    m_ctrl_factory_pool.setSrcPatterns(<span class="stringliteral">&quot;epics&quot;</span>, ew.srcPatterns());</div><div class="line">    cumbia_pool-&gt;setSrcPatterns(<span class="stringliteral">&quot;epics&quot;</span>, ew.srcPatterns());</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef QUMBIA_TANGO_CONTROLS</span></div><div class="line">    CumbiaTango* cuta = <span class="keyword">new</span> CumbiaTango(<span class="keyword">new</span> CuThreadFactoryImpl(), <span class="keyword">new</span> QThreadsEventBridgeFactory());</div><div class="line">    cumbia_pool-&gt;registerCumbiaImpl(<span class="stringliteral">&quot;tango&quot;</span>, cuta);</div><div class="line">    m_ctrl_factory_pool.registerImpl(<span class="stringliteral">&quot;tango&quot;</span>, <a class="code" href="classCuTWriterFactory.html">CuTWriterFactory</a>());  <span class="comment">// register Tango writer implementation</span></div><div class="line">    m_ctrl_factory_pool.registerImpl(<span class="stringliteral">&quot;tango&quot;</span>, <a class="code" href="classCuTReaderFactory.html">CuTReaderFactory</a>());  <span class="comment">// register Tango reader implementation</span></div><div class="line"></div><div class="line">    CuTangoWorld tw;   <span class="comment">// Tango cumbia helper class</span></div><div class="line">    m_ctrl_factory_pool.setSrcPatterns(<span class="stringliteral">&quot;tango&quot;</span>, tw.srcPatterns());</div><div class="line">    cu_pool-&gt;setSrcPatterns(<span class="stringliteral">&quot;tango&quot;</span>, tw.srcPatterns());</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">}</div></div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Dec 10 2019 17:06:49 for qumbia-tango-controls by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
