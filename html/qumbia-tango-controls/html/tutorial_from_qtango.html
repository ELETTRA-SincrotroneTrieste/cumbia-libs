<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>qumbia-tango-controls: Porting a QTango application to cumbia-tango</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">qumbia-tango-controls
   &#160;<span id="projectnumber">1.x</span>
   </div>
   <div id="projectbrief">Library on top of cumbia-qtcontrols and cumbia-tango</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Porting a QTango application to cumbia-tango </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this tutorial we will learn how to port a QTango application to cumbia. Additionally, <a href="tutorial_faq.html">frequently asked questions</a> page illustrates some more porting examples.</p>
<h1>Demo code used in the examples in this page</h1>
<p>A couple of QTango applications are shipped within the qumbia-apps/qumbiaprojectwizard utility source code:</p>
<ul>
<li>qumbia-apps/qumbiaprojectwizard/demos/qtango_porting/simple_qtango_danfisik9100</li>
<li>qumbia-apps/qumbiaprojectwizard/demos/qtango_porting/complex_qtango_demo</li>
</ul>
<p>They cannot be build without the QTango library but they are full working projects. The code can be used to test <em>qumbiaprojectwizard</em> and to try to port the applications following this tutorial. You may want to read the <em>README</em> files under the directories listed above.</p>
<h1>1. Simple QTango applications with QTango base classes</h1>
<p>How to tell whether a QTango project is or not a simple application that can be easily ported?</p>
<p>A simple QTango application</p>
<ul>
<li>typically consists of a few source files: a main.cpp, a widget.cpp, a widget.h and a <em>ui</em> file edited with the Qt designer</li>
<li>if more source files make up the project, they only contain the QTango base classes listed below or do not contain QTango code at all</li>
<li>is made up of QTango base classes only, like TLabel, TPushButton, TPlotLightMarker, TCircularGauge, TLineEdit, TApplyNumeric, TReaderWriter, TDoubleSpinBox, TSpinBox, TApplication, TCheckBox, TSimpleLabel and does not employ <em>custom</em> QTango classes, i.e. objects derived from QTangoComProxyReader, QTangoComProxyWriter, QTangoWidgetCommon</li>
<li><em>does not use</em> classes such as TVariant, DeviceThread, DeviceThreadFactory, TAction, PropertyReader, EUniqueApplication, EApplicationButton, SpectrumWriter, ReadersGroup TDbBrowser, TWidgetGroup, TUniqueApplication, ...</li>
<li>has a *.pro* file starting with a line that looks like <em>include(/usr/local/qtango/include/qtango6/qtango.pri)</em></li>
</ul>
<p>To do the following exercise you can refer to the <em>demo code</em> in</p>
<ul>
<li>qumbia-apps/qumbiaprojectwizard/demos/qtango_porting/simple_qtango_danfisik9100</li>
</ul>
<div class="image">
<img src="qumbiaprojectwizard-import.png" alt=""/>
<div class="caption">
qumbiaprojectwizard application: import a QTango application</div></div>
 <p>An application with such prerequisites can be ported with the help of the <em>qumbiaprojectwizard</em> utility by selecting <em>Import</em> and then <em>Import a simple QTango project</em>, as shown in the picture above.</p>
<p>Please <em>note</em> that <em>qumbiaprojectwizard</em> does its best but it is likely you must fix several issues in order to correctly complete the porting process.</p>
<p>After clicking the <em>Import a simple QTango project</em>, you will be prompted to select a Qt *.pro* file with a valid qtango application. Select the <em>/path/to/your/cumbia/sources/qumbia-apps/qumbiaprojectwizard/demos/qtango_porting/simple_qtango_danfisik9100/danfisik9100.pro</em> file in the dialog box. Once a qtango project file is selected, <em>qumbiaprojectwizard</em> fills in the form with the *project name, author, author email, file and class names according to what has been detected in the project.</p>
<div class="image">
<img src="qumbiaprojectwizard-import2.png" alt=""/>
<div class="caption">
qumbiaprojectwizard application: a QTango project has been correctly detected</div></div>
 <p>Once a project has been correctly detected, you can try to convert it clicking on the <em>Convert...</em> button at the bottom of the utility. If everything is likely to be ok, you should only find <em>green or yellow</em> lines in the list view describing the process. Pay attention to this information and read it carefully before <em>double checking</em> the <em>Output directory</em> for the converted project and clicking on the <em>Convert</em> button on the bottom left. If the chosen <em>output directory</em> is <em>the same as the qtango</em> application, a backup of the old project is done by qumbiaprojectwizard. By default, unless you explicitly select the <em>same directory as the qtango application</em>, a <em>to_cumbia</em> folder is created and there the converted files are put.</p>
<div class="image">
<img src="qumbiaprojectwizard-import3.png" alt=""/>
<div class="caption">
qumbiaprojectwizard application: conversion output</div></div>
 <p>We recommend not generating the output files in the same directory as the QTango original project unless you are sure that the porting can be successfully accomplished. Once the <em>Convert</em> button is pressed on the dialog box shown in the picture above, the files are written in the desired <em>output directory</em>. Check the converted project, fix the remaining issues and compile your new <em>cumbia</em> application!</p>
<p>When the above dialog window is closed, <em>qtcreator</em> and <em>qt designer</em> can be automatically launched in the output directory if the corresponding checkboxes in the main qumbiaprojectwizard window are checked.</p>
<div class="image">
<img src="qumbiaprojectwizard-import4.png" alt=""/>
<div class="caption">
qumbiaprojectwizard application: open qt creator and qt designer after a successful porting</div></div>
 <h2>Important note</h2>
<p>Always remember that:</p>
<ul>
<li>automatic porting only works when the QTango project is very simple</li>
<li>automatic porting <em>usually helps</em> a lot migrating a project to cumbia, even when dealing with complex projects</li>
</ul>
<p>As a consequence:</p>
<ul>
<li>several times you will have to fix the remaining issues manually</li>
</ul>
<h1>2. Complex QTango application with <em>application specific</em> QTango classes</h1>
<p>A complex QTango application normally</p>
<ul>
<li>defines and uses new classes that are specific to that application, readers deriving from QTangoComProxyReader or writers deriving from QTangoComProxyWriter.</li>
<li>is made up of more than three <em>cpp</em> or <em>header</em> files</li>
<li>needs to access QTango low level objects, such as TVariant, TAction, QTangoCommunicationHandle and the aforementioned QTangoComProxyReader/QTangoComProxyWriter</li>
<li>uses objects that do not have a counterpart in <em>cumbia</em>: EUniqueApplication, SpectrumWriter, ReadersGroup, TWidgetGroup, TUniqueApplication, PropertyReader</li>
</ul>
<p>Complex QTango projects need to follow the generic porting instructions below. They are valid for simple projects as well.</p>
<h2>*qumbiaprojectwizard* for complex QTango applications.</h2>
<p>The <em>qumbiaprojectwizard</em> utility can be used to help the porting process. It can convert the main.cpp, the mainwidget definition (*.h*) and implementation (*.cpp*), the *.pro* file and the <em>ui</em> xml file generated with the Qt designer. It can also try to perform simple conversion in all the remaining <em>cpp</em> and <em>header</em> files in the project folder.</p>
<p>Open the utility, click on <em>Import a simple QTango project</em> and select the <em>ComplexQTangoDemo.pro</em> file under the demos/qtango_porting/complex_qtango_demo/ directory:</p>
<p><em>/path/to/your/cumbia/sources/qumbia-apps/qumbiaprojectwizard/demos/qtango_porting/complex_qtango_demo/ComplexQTangoDemo.pro</em></p>
<div class="image">
<img src="qumbiaprojectwizard-import-complex1.png" alt=""/>
<div class="caption">
qumbiaprojectwizard application: all project components are detected</div></div>
 <p>Let's look at the <em>ComplexQTangoDemo.pro</em> <em>FORMS</em> section:</p>
<div class="fragment"><div class="line">FORMS    = src/ComplexQTangoDemo.ui \</div>
<div class="line">    src/demodialog.ui</div>
</div><!-- fragment --><p>As you see, there's more than one <em>ui</em> file. <em>qumbiaprojectwizard</em> is able to determine the <em>UI form class name</em> only if</p>
<ul>
<li>there is one *.ui file in the project</li>
<li>there are several *.ui files, but the <em>first "class" child of the ui element</em> (that is, the object name of the top level widget) has <em>the same name as the main application widget name</em></li>
</ul>
<p>In this example, the second condition is satisfied, as shown below.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">main.cpp file </th><th class="markdownTableHeadCenter">ui file in Qt designer </th><th class="markdownTableHeadCenter">ui file (xml insight)  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><div class="image">
<img src="maincpp1.png" alt=""/>
</div>
     </td><td class="markdownTableBodyCenter"><div class="image">
<img src="form1.png" alt=""/>
</div>
     </td><td class="markdownTableBodyCenter"><div class="image">
<img src="uixml1.png" alt=""/>
</div>
      </td></tr>
</table>
<p>Thanks to this condition, <em>qumbiaprojectwizard</em> correctly detects the UI form class name. Now click the <em>Convert</em> button.</p>
<p>The <em>ComplexQTangoDemo</em> panel includes a custom reader (TDialRead) that <em>is</em> a <em>QTangoComProxyReader</em> and a custom writer (TDialWrite) that <em>is</em> a <em>QTangoComProxyWriter</em>. Other two objects are one custom reader and one custom writer, but they use QTWatcher and QTWriter to communicate with <em>tango</em>.</p>
<p>A dialog box asks to choose between</p>
<ul>
<li>QuTrendPlot and</li>
<li>QuSpectrumPlot</li>
</ul>
<p>when migrating from QTango TPlotLightMarker. QTango TPlotLightMarker adapts to display either scalars or spectrum values. <em>cumbia</em> graphs are specialised to display either one or the other data format and one must be chosen. Select QuTrendPlot in the <em>box</em> and click on <em>Choose</em>, since the attribute displayed by the plot in the complex_qtango_demo application is a scalar double.</p>
<p>The conversion process shows some error messages in red:</p>
<div class="image">
<img src="qumbiaprojectwizard-import-complex2.png" alt=""/>
<div class="caption">
qumbiaprojectwizard application: conversion errors due to unsupported QTango elements</div></div>
 <p>The contents described in the <em>red</em> items cannot be ported automatically. The issues must be solved by the programmer later on. Nonetheless, as you can see, much work has been done automatically. Carefully read <em>all the</em> messages in the list before proceeding to the actual migration, then generate the converted code. Select an output directory through the <em>Change</em> button and the file input dialog that follows. We choose to generate the code under:</p>
<p><em>/path/to/your/cumbia/sources/qumbia-apps/qumbiaprojectwizard/demos/qtango_porting/complex_qtango_demo/to_cumbia</em></p>
<p>Enable the <em>OK, try your best...</em> box and click on <em>Convert</em>. If the <em>Launch applications after files are created</em> check boxes are enabled, the <em>qt creator and qt designer</em> applications should be launched in the output directory. We will use these tools to correct the remaining errors and port the <em>custom reader</em> from QTango to cumbia.</p>
<h3>Run cuuimake on the partially ported project</h3>
<p>Momentarily open a terminal, go into the partially converted project folder and run <em>cuuimake</em>:</p>
<div class="fragment"><div class="line">cd /path/to/cumbia-libs/qumbia-apps/qumbiaprojectwizard/demos/qtango_porting/complex_qtango_demo/to_cumbia</div>
<div class="line"> </div>
<div class="line">cuuimake --qmake</div>
</div><!-- fragment --><div class="image">
<img src="cuuimake-output.png" alt=""/>
<div class="caption">
output from the *cuuimake* utility</div></div>
 <p>If you execute <em>make</em> on the command line, you will get a lot of complaints from the compiler.</p>
<div class="image">
<img src="build-errors1.png" alt=""/>
<div class="caption">
output from the compiler</div></div>
 <p>The main issues concern custom classes inheriting from QTangoComProxyReader and QTangoComProxyWriter. They cannot be ported by <em>qumbiaprojectwizard</em>. Please follow the generic porting instructions that follow.</p>
<h1>Porting a QTango application to <em>cumbia</em>. Generic instructions.</h1>
<p>Let's analyze again the complex_qtango_demo project in this section. If you have partially ported this demo application using <em>qumbiaprojectwizard</em> and following the instructions above, you should now be stuck in the compilation errors shown in the picture above. In this case, the following files should have been correctly migrated:</p>
<ul>
<li>ComplexQTangoDemo.pro</li>
<li>src/ComplexQTangoDemo.cpp</li>
<li>src/ComplexQTangoDemo.h</li>
<li>src/demodialog.cpp</li>
<li>src/demodialog.h</li>
</ul>
<p>while the files:</p>
<ul>
<li>src/tdialread.h</li>
<li>src/tdialread.cpp</li>
<li>src/tdialwrite.h</li>
<li>src/tdialwrite.cpp</li>
</ul>
<p>must be corrected manually.</p>
<p>In this case, you can skip to the <a href="#Migrate-QTangoComProxyReader-derived-objects">migrating QTangoComProxyReader derived objects</a></p>
<h2>The Qt <em>project</em> file</h2>
<p>Every QTango project is built using Qt <em>qmake</em>. Let's start analyzing the <em>ComplexQTangoDemo .pro file</em></p>
<p>Every QTango project has a project file resembling this:</p>
<div class="fragment"><div class="line">include (/usr/local/qtango/include/qtango6/qtango.pri)</div>
<div class="line"> </div>
<div class="line">TEMPLATE = app</div>
<div class="line"> </div>
<div class="line">OBJECTS_DIR = obj</div>
<div class="line"> </div>
<div class="line"># RESOURCES += </div>
<div class="line"> </div>
<div class="line">INCLUDEPATH += src</div>
<div class="line"> </div>
<div class="line">SOURCES += src/main.cpp \</div>
<div class="line">                src/ComplexQTangoDemo.cpp \</div>
<div class="line">    src/tdialread.cpp \</div>
<div class="line">    src/tdialwrite.cpp \</div>
<div class="line">    src/demodialog.cpp</div>
<div class="line"> </div>
<div class="line">HEADERS += src/ComplexQTangoDemo.h \</div>
<div class="line">    src/tdialread.h \</div>
<div class="line">    src/tdialwrite.h \</div>
<div class="line">    src/demodialog.h</div>
<div class="line"> </div>
<div class="line">FORMS    = src/ComplexQTangoDemo.ui \</div>
<div class="line">    src/demodialog.ui</div>
<div class="line"> </div>
<div class="line">TARGET   = bin/complex_qtango_demo</div>
</div><!-- fragment --><p>More complex projects can contain several directives in the *.pro* file (such as <em>QT, CONFIG, LIBS, INCLUDES, RESOURCES</em>) but, as far as QTango is concerned, only the first line is relevant:</p>
<div class="fragment"><div class="line">include(/usr/local/qtango/include/qtango6/qtango.pri)</div>
</div><!-- fragment --><p>When migrating to <em>cumbia</em>, this line must be replaced by</p>
<div class="fragment"><div class="line">include (/usr/local/include/qumbia-tango-controls/qumbia-tango-controls.pri)</div>
</div><!-- fragment --><p>in the hypothesis where <em>cumbia</em> libs are installed under /usr/local (includes in /usr/local/include/...).</p>
<p>The <em>main.cpp</em> file in a QTango project used to register with the window manager:</p>
<div class="fragment"><div class="line">/* register to window manager */</div>
<div class="line">Display *disp = QX11Info::display();</div>
<div class="line">Window root_win = (Window) mw.winId();</div>
<div class="line">XSetCommand(disp, root_win, argv, argc);</div>
</div><!-- fragment --><p>if this feature is still desired, you must add</p>
<div class="fragment"><div class="line">PKGCONFIG += x11</div>
</div><!-- fragment --><p>and</p>
<div class="fragment"><div class="line">greaterThan(QT_MAJOR_VERSION, 4): QT += x11extras</div>
</div><!-- fragment --><p>to the project *.pro* file, so that <em>-lX11</em> is used by the linker and the <em>Qt</em> file</p>
<div class="fragment"><div class="line">#include &lt;QX11Info&gt;</div>
</div><!-- fragment --><p>included by <em>main.cpp</em> is found.</p>
<p>Please note that registration with the window manager should not be necessary. Execution of <em>unique</em> applications and raising/hiding the application windows is managed by the <em>cumbia dbus plugin</em>.</p>
<p>Since the ported project's <em>ui</em> file will be processed by the <em>cuuimake</em> utility that is run before <em>make</em>, we must add the <em>ui</em> folder to the project <em>INCLUDEPATH</em>, because <em>cuuimake</em> generates the ui_*.h file under the <em>ui</em> subfolder. Additionally, since ui_*.h files generated under the <em>ui</em> dir can include headers placed under the <em>src</em> project folder, we must add <em>src</em> to the INCLUDEPATH as well:</p>
<div class="fragment"><div class="line">INCLUDEPATH += ui src</div>
</div><!-- fragment --><p>The <em>cuuimake</em> utility <em>runs uic</em> on the project <em>.ui</em> files. This means that <em>qmake must not run uic</em> when compiling a <em>cumbia</em> project. That's because <em>cumbia cuuimake</em> creates the <em>ui_*.h</em> files so that the <em>cumbia-qtcontrols</em> class constructors are expanded to match the expected parameters.</p>
<p>You may want to read the <a href="../../cumbia-qtcontrols/html/understanding_cumbia_qtcontrols_constructors.html">Understanding the cumbia-qtcontrols widgets constructors, sources and targets</a> documentation and the <a href="../../cuuimake/html/md_src_cuuimake.html">Using <em>cuuimake manual</em></a> for further details.</p>
<div class="fragment"><div class="line">#   comment the FORMS directive: cuuimake runs uic</div>
<div class="line">#</div>
<div class="line">#       FORMS    = src/danfisik9100.ui</div>
</div><!-- fragment --><p>This is all you need to port a qtango *.pro* file to <em>cumbia</em>.</p>
<h2>The .pro project file: summary</h2>
<p>Putting this altogether, the relevant changes to the project file are as follows:</p>
<div class="fragment"><div class="line"># 1. remove qtango project include file</div>
<div class="line"># include(/usr/local/qtango/include/qtango6/qtango.pri)</div>
<div class="line"> </div>
<div class="line">include (/usr/local/include/qumbia-tango-controls/qumbia-tango-controls.pri)</div>
<div class="line"> </div>
<div class="line"># 2. add this only if main.cpp registers the application to the X window manager</div>
<div class="line"> </div>
<div class="line">greaterThan(QT_MAJOR_VERSION, 4): QT += x11extras</div>
<div class="line">PKGCONFIG += x11</div>
<div class="line"> </div>
<div class="line"># cuuimake runs uic</div>
<div class="line">#       FORMS    = src/danfisik9100.ui</div>
<div class="line">#</div>
<div class="line"> </div>
<div class="line"># where to find cuuimake ui_*.h files</div>
<div class="line"># since FORMS is not used</div>
<div class="line">#</div>
<div class="line">INCLUDEPATH += ui src</div>
</div><!-- fragment --><h2>The <em>main.cpp</em> file</h2>
<p>QTango specific include files must be removed:</p>
<div class="fragment"><div class="line">// #include &lt;TApplication&gt;</div>
<div class="line">// #include &lt;elettracolors.h&gt;</div>
<div class="line">// #include &lt;tutil.h&gt;</div>
<div class="line"> </div>
<div class="line">#include &quot;danfisik9100.h&quot;</div>
<div class="line">#include &lt;X11/Xlib.h&gt;</div>
<div class="line">#include &lt;QX11Info&gt;</div>
</div><!-- fragment --><p>and cumbia includes must be added:</p>
<div class="fragment"><div class="line">#include &lt;cumbiatango.h&gt;</div>
<div class="line">#include &lt;cuthreadfactoryimpl.h&gt;</div>
<div class="line">#include &lt;qthreadseventbridgefactory.h&gt;</div>
<div class="line">#include &lt;quapplication.h&gt;</div>
</div><!-- fragment --><p>These includes reveal the name of the objects that are used in the <em>main.cpp</em> lines. Let's get into more detail.</p>
<ul>
<li>TApplication becomes QuApplication (#include &lt;quapplication.h&gt;)</li>
<li>EPalette is not used anymore</li>
<li>TUtil was a QTango class and all its references must be removed</li>
<li>to correctly accomplish object destruction when the application terminates, the main widget (if there's one) must be allocated in the heap and some <em>cumbia</em> specific objects must be deleted after QApplication::exec is over</li>
<li>CumbiaTango is usually instantiated in the <em>main.cpp</em> and a pointer to it is passed to the main widget</li>
<li>when QApplication::exec returns, the main widget and the CumbiaTango instances are deleted</li>
</ul>
<p>With these considerations, the modified <em>main.cpp</em> looks like this:</p>
<div class="fragment"><div class="line">int main(int argc, char *argv[])</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">//     TApplication qu_app( argc, argv );</div>
<div class="line">    QuApplication qu_app( argc, argv );//       TApplication is mapped into QuApplication. DBus connection is provided by cumbia dbus plugin    //       ## added by qumbiaprojectwizard</div>
<div class="line">    qu_app.setApplicationName(&quot;-&quot;);</div>
<div class="line">    qu_app.setProperty(&quot;author&quot;, &quot;Giacomo&quot;);</div>
<div class="line">    </div>
<div class="line">//  TUtil::instance()-&gt;setLoggingTarget(argv[0]);</div>
<div class="line">//      QTango TUtil:: class is not present in cumbia   //       ## added by qumbiaprojectwizard</div>
<div class="line"> </div>
<div class="line">    CumbiaTango *cu_t = new CumbiaTango(new CuThreadFactoryImpl(), new QThreadsEventBridgeFactory());</div>
<div class="line">    ComplexQTangoDemo *w = new ComplexQTangoDemo(cu_t, 0);</div>
<div class="line">    w-&gt;show();</div>
<div class="line"> </div>
<div class="line">    Display *disp = QX11Info::display();</div>
<div class="line">    Window root_win = (Window) w-&gt;winId();</div>
<div class="line">    XSetCommand(disp, root_win, argv, argc);</div>
<div class="line">// exec application loop</div>
<div class="line">    int ret = qu_app.exec();</div>
<div class="line">    // delete resources and return</div>
<div class="line">    delete w;</div>
<div class="line">    delete cu_t;</div>
<div class="line">    return ret;</div>
<div class="line">}</div>
</div><!-- fragment --><p>That's all for the <em>main.cpp</em> file. The <em>qumbiaprojectwizard</em> is designed to do these steps automatically.</p>
<h2>The mainwidget.h header file</h2>
<p>The QTango header file defining the <em>main widget</em> of the examined application looks like this:</p>
<div class="fragment"><div class="line">#include &lt;QWidget&gt;</div>
<div class="line"> </div>
<div class="line">namespace Ui {</div>
<div class="line">class ComplexQTangoDemo;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">class ComplexQTangoDemo : public QWidget</div>
<div class="line">{</div>
<div class="line">    Q_OBJECT</div>
<div class="line">public:</div>
<div class="line">    explicit ComplexQTangoDemo(QWidget *parent = 0);</div>
<div class="line">    ~ComplexQTangoDemo();</div>
<div class="line">private slots:</div>
<div class="line">    void execDemoDialog();</div>
<div class="line">private:</div>
<div class="line">    void m_setup(); // install QTWatcher and QTWriter, set source/targets on custom reader and writer</div>
<div class="line">    Ui::ComplexQTangoDemo *ui;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Since <em>cumbia-qtcontrols</em> objects are parametrized with an instance of <em>Cumbia</em> and a <em>reader or writer factory</em> (or both if the same object is designed both to read <em>and</em> write), pointers or references to these objects must be passed to the main widget constructor so that children can be properly parametrized.</p>
<p>Start adding the needed include files. The top of the <em>header</em> file now looks like this:</p>
<div class="fragment"><div class="line">// cumbia-tango</div>
<div class="line">#include &lt;qulogimpl.h&gt;</div>
<div class="line">#include &lt;cutcontrolsreader.h&gt;</div>
<div class="line">#include &lt;cutcontrolswriter.h&gt;</div>
<div class="line">#include &lt;cumbiatango.h&gt;</div>
<div class="line">// cumbia-tango</div>
<div class="line"> </div>
<div class="line">#include &lt;QWidget&gt;</div>
<div class="line"> </div>
<div class="line">// ...</div>
</div><!-- fragment --><p>The class constructor is expanded to accept a pointer to <em>CumbiaTango</em>:</p>
<div class="fragment"><div class="line">class ComplexQTangoDemo : public QWidget</div>
<div class="line">{</div>
<div class="line">    Q_OBJECT</div>
<div class="line">public:</div>
<div class="line">    ComplexQTangoDemo(CumbiaTango *cut, QWidget *parent = 0);</div>
</div><!-- fragment --><p>In a <em>cumbia</em> app, the class attribute storing the main widget <em>form</em> ("ui") must be a pointer. In this example, it was already a pointer:</p>
<div class="fragment"><div class="line">// in QTango can be:</div>
<div class="line">// Ui::ComplexQTangoDemo ui;</div>
<div class="line"> </div>
<div class="line">// in cumbia we must declare the form as a pointer</div>
<div class="line">Ui::ComplexQTangoDemo *ui;</div>
</div><!-- fragment --><p>Finally, a bunch of new class attributes must be defined (private):</p>
<div class="fragment"><div class="line">private:</div>
<div class="line">    Ui::ComplexQTangoDemo *ui;</div>
<div class="line">// cumbia-tango</div>
<div class="line">    CumbiaTango *cu_t;</div>
<div class="line">    CuTReaderFactory cu_tango_r_fac;</div>
<div class="line">    CuTWriterFactory cu_tango_w_fac;</div>
<div class="line">    QuLogImpl m_log_impl;               // optional logging facility</div>
<div class="line">    CuLog *m_log;                       // optional logging facility</div>
<div class="line">};</div>
</div><!-- fragment --><h2>The mainwidget.h header file: summary</h2>
<p>The cumbia version of the simple QTango main widget header file looks like this at last:</p>
<div class="fragment"><div class="line">#include &lt;qulogimpl.h&gt; // cumbia-tango includes start</div>
<div class="line">#include &lt;cutcontrolsreader.h&gt;</div>
<div class="line">#include &lt;cutcontrolswriter.h&gt;</div>
<div class="line">#include &lt;cumbiatango.h&gt; // cumbia-tango includes end</div>
<div class="line"> </div>
<div class="line">#include &lt;QWidget&gt;</div>
<div class="line"> </div>
<div class="line">namespace Ui {</div>
<div class="line">class ComplexQTangoDemo;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">class ComplexQTangoDemo : public QWidget</div>
<div class="line">{</div>
<div class="line">    Q_OBJECT</div>
<div class="line">public:</div>
<div class="line">    explicit ComplexQTangoDemo(CumbiaTango *cut, QWidget *parent = 0);</div>
<div class="line">    ~ComplexQTangoDemo();             // class destructor</div>
<div class="line">private slots:</div>
<div class="line">    void execDemoDialog();            // slot to execute a dialog, cumbia independent</div>
<div class="line">private:</div>
<div class="line">    void m_setup();</div>
<div class="line">    Ui::ComplexQTangoDemo *ui;        // must be a pointer</div>
<div class="line"> </div>
<div class="line">    CumbiaTango *cu_t;</div>
<div class="line">    CuTReaderFactory cu_tango_r_fac;</div>
<div class="line">    CuTWriterFactory cu_tango_w_fac;</div>
<div class="line">    QuLogImpl m_log_impl;           // optional logging facility</div>
<div class="line">    CuLog *m_log;                   // optional logging facility</div>
<div class="line">};</div>
</div><!-- fragment --><h2>The mainwidget.cpp: the implementation of the main application widget</h2>
<p>See how the main widget class constructor implementation used to look like in QTango:</p>
<div class="fragment"><div class="line">ComplexQTangoDemo::ComplexQTangoDemo(QWidget *parent) :</div>
<div class="line">    QWidget(parent),</div>
<div class="line">    ui(new Ui::ComplexQTangoDemo)</div>
<div class="line">{</div>
<div class="line">    ui-&gt;setupUi(this);</div>
<div class="line">    m_setup();</div>
<div class="line">}</div>
</div><!-- fragment --><p>and do examine how things must be modified in order to write a <em>cumbia</em> compliant main widget class constructor.</p>
<p>In this example we include the logging facility. In cumbia it is registered through a <em>service provider</em> (there are no singleton classes in <em>cumbia</em>).</p>
<p>The main widget constructor implementation does the following:</p>
<ul>
<li>assigns the pointer to the CumbiaTango allocated in the main.cpp to the <em>cu_t</em> class attribute</li>
<li>sets up the logging facility</li>
<li>instantiates the Ui form and calls <em>setupUI</em> with the additional parameters that the form will forward to the cumbia-qtcontrols objects constructors</li>
<li>instantiates the <em>CuContextActionBridge</em> to give <em>cumbia-qtcontrols</em> children the capability to provide a right click contextual menu</li>
</ul>
<p>The following code shows the modified main widget constructor in the ComplexQTangoDemo.cpp file. The necessary include files are also listed.</p>
<div class="fragment"><div class="line">#include &quot;ComplexQTangoDemo.h&quot;</div>
<div class="line"> </div>
<div class="line">#include &lt;cuserviceprovider.h&gt; // cumbia-tango includes start </div>
<div class="line">#include &lt;cucontextactionbridge.h&gt;</div>
<div class="line">#include &lt;cumacros.h&gt; // cumbia-tango includes end </div>
<div class="line"> </div>
<div class="line">#include &quot;ui_ComplexQTangoDemo.h&quot;</div>
<div class="line">#include &quot;demodialog.h&quot;</div>
<div class="line"> </div>
<div class="line">ComplexQTangoDemo::ComplexQTangoDemo(CumbiaTango *cut, QWidget *parent) :</div>
<div class="line">    QWidget(parent)     /* ,    ui(new Ui::ComplexQTangoDemo)     // ## qumbiaprojectwizard: instantiated in constructor body */</div>
<div class="line">{</div>
<div class="line">    cu_t = cut;  // cumbia-tango section starts</div>
<div class="line">    m_log = new CuLog(&amp;m_log_impl);</div>
<div class="line">    cu_t-&gt;getServiceProvider()-&gt;registerService(CuServices::Log, m_log);</div>
<div class="line"> </div>
<div class="line">    ui = new Ui::ComplexQTangoDemo;</div>
<div class="line">    ui-&gt;setupUi(this, cu_t, cu_tango_r_fac, cu_tango_w_fac);  // cumbia-tango section ends</div>
<div class="line">    </div>
<div class="line">    m_setup();</div>
<div class="line">    new CuContextActionBridge(this, cu_t, cu_tango_r_fac);</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p>Please note that the <em>ui_ComplexQTangoDemo.h</em> file, expanded by <em>cuuimake</em>, resides under the <em>ui</em> subfolder of the project.</p>
<p>Remember that the line</p>
<div class="fragment"><div class="line">new CuContextActionBridge(this, cu_t, cu_tango_r_fac);</div>
</div><!-- fragment --><p>must be at the end of the method. In this way, all the <em>cumbia-qtcontrols</em> widgets instantiated above it can offer a contextual menu. See the CuContextActionBridge documentation for further details.</p>
<p>The line</p>
<div class="fragment"><div class="line">ui-&gt;setupUi(this, cu_t, cu_tango_r_fac, cu_tango_w_fac);</div>
</div><!-- fragment --><p>takes into account the <em>expanded setupUi</em> method that now accepts additional arguments to appropriately instantiate its <em>cumbia-qtcontrols</em> children.</p>
<p>The <em>m_setup</em> private method attaches the QTWatcher and QTWriter to the corresponding widgets and sets the source and target of the custom <em>QTangoComProxyReader and QTangoComProxyWriter</em> widgets. The code can be directly inspected from the ComplexQTangoDemo.cpp file and the contents of the method body are correctly migrated by <em>qumbiaprojectwizard</em>.</p>
<h2>Note</h2>
<p>The <em>qumbiaprojectwizard</em> "*Import from QTango*" function should help expanding the main widget definition and class constructor as described in the example above. <em>qumbiaprojectwizard</em> can help if the project is made up of numerous <em>header</em> and <em>source</em> files if they either employ QTango base classes or do not contain QTango specific code.</p>
<h2>Building the ported project</h2>
<p>The project can be now built:</p>
<div class="fragment"><div class="line">cuuimake --qmake --make</div>
</div><!-- fragment --><p>or</p>
<div class="fragment"><div class="line">cuuimake --qmake -j5</div>
</div><!-- fragment --><h2>Migrate QTangoComProxyReader derived objects</h2>
<p>A more complex QTango application may define and use custom QTango reader classes. For example <em>tree view</em>, <em>tree widget</em> or <em>progress bar</em> are used to read values. Components not included in the QTango library can become readers in two ways:</p>
<ul>
<li>inherit from QTangoComProxyReader and implement</li>
</ul>
<div class="fragment"><div class="line">virtual void refresh(const TVariant &amp;) = 0;</div>
</div><!-- fragment --><ul>
<li>use QTWatcher attached to the display component.</li>
</ul>
<p>In the second case, <em>QuWatcher</em> can be used. Its interface is equivalent to <em>QTWatcher</em>'s. In most cases, it is possible to migrate from the latter to the former by means of the <em>qumbiaprojectwizard</em> utility.</p>
<p>Inheritance from QTangoComProxyReader, implies the following observations. The discussion continues related to</p>
<p>*/path/to/cumbia-libs/qumbia-apps/qumbiaprojectwizard/demos/qtango_porting/complex_qtango_demo*</p>
<p>The QTango class definition is this:</p>
<div class="fragment"><div class="line">class TDialRead : public QDial, public QTangoComProxyReader, public QTangoWidgetCommon</div>
<div class="line">{</div>
<div class="line">    Q_OBJECT</div>
</div><!-- fragment --><p>Inheritance from <em>QTangoComProxyReader</em> and <em>QTangoWidgetCommon</em> must be removed. The corresponding include files must be removed too. <em>QTangoComProxyReader</em> was an <em>abstract class</em>, <em>QTangoWidgetCommon</em> a concrete base class. In <em>cumbia</em> multiple inheritance involves <em>interfaces only</em>.</p>
<p>Remove this:</p>
<div class="fragment"><div class="line">#include &lt;com_proxy_reader.h&gt;</div>
<div class="line">#include &lt;qtango_wcommon.h&gt;</div>
</div><!-- fragment --><p>Remove other <em>qtango</em> include directives as well, such as <em>TVariant, view_trend.h</em>, ...</p>
<p>To start porting the custom class to <em>cumbia</em>, rewrite the class definition as follows and add the needed include files:</p>
<div class="fragment"><div class="line">#include &lt;QLabel&gt;</div>
<div class="line">#include &lt;cudatalistener.h&gt;</div>
<div class="line">#include &lt;cucontexti.h&gt;</div>
<div class="line">#include &lt;cudata.h&gt;</div>
<div class="line"> </div>
<div class="line">// it&#39;s enough to declare these, since header file involves only pointer or const references to them</div>
<div class="line">class Cumbia;</div>
<div class="line">class CumbiaPool;</div>
<div class="line">class CuControlsReaderFactoryI;</div>
<div class="line">class CuControlsFactoryPool;</div>
<div class="line">class CuContext;</div>
<div class="line">class CuLinkStats;</div>
<div class="line"> </div>
<div class="line">class QuLabel : public QLabel, public CuDataListener, public CuContextI</div>
<div class="line">{</div>
<div class="line">    Q_OBJECT</div>
</div><!-- fragment --><p>The <em>CuDataListener</em> interface defines a <em>callback</em> to receive data from the underlying engine. The method</p>
<div class="fragment"><div class="line">void onUpdate(const CuData &amp;d);</div>
</div><!-- fragment --><p>must be implemented.</p>
<p>The <em>CuContextI</em> interface defines one pure virtual method that must be implemented:</p>
<div class="fragment"><div class="line">virtual CuContext *getContext() const = 0;</div>
</div><!-- fragment --><p>The Context is a class that holds link statistics, creates and destroys readers and writers.</p>
<p>If you write the project with <em>qtcreator</em>, right click on the class name and choose <em>Refactor -&gt; Insert Virtual Function of Base Classes</em></p>
<p>Remove the <em>refresh</em> and <em>autoConfigure</em> methods belonging to <em>qtango</em>:</p>
<div class="fragment"><div class="line">protected slots:</div>
<div class="line">    virtual void refresh(const TVariant &amp;);</div>
<div class="line"> </div>
<div class="line">    void autoConfigure(const TangoConfigurationParameters *cp);</div>
</div><!-- fragment --><p>The class constructors must be expanded to include additional parameters (see <a href="../../cumbia-qtcontrols/html/understanding_cumbia_qtcontrols_constructors.html">Understanding the cumbia-qtcontrols widgets constructors, sources and targets</a> documentation).</p>
<p>Normally, in a generic cumbia-qtcontrols widget two constructor versions are provided, but if you are writing an application that is specific to an engine (e.g. either Tango or Epics), then only one constructor version is enough. In the following code, you can also see the declaration of the methods implementing the aforementioned interfaces. The <em>source</em> and <em>setSource</em> methods, that came for free in the <em>QTango</em> reader from the <em>QTangoComProxyReader</em>, must be explicitly declared and implemented in TDialRead. This is necessary due to the more free nature of a <em>cumbia</em> widget, decoupled from any specific control system engine:</p>
<div class="fragment"><div class="line">class TDialRead : public QDial, public CuDataListener, public CuContextI</div>
<div class="line">{</div>
<div class="line">    Q_OBJECT</div>
<div class="line">public:</div>
<div class="line">    TDialRead(QWidget *w, Cumbia *cumbia, const CuControlsReaderFactoryI &amp;r_fac);</div>
<div class="line"> </div>
<div class="line">    // CuContextI interface</div>
<div class="line">    virtual CuContext *getContext() const;</div>
<div class="line">    // CuDataListener interface</div>
<div class="line">    virtual void onUpdate(const CuData &amp;data);</div>
<div class="line">    </div>
<div class="line">    QString source() const;</div>
<div class="line">    </div>
<div class="line">public slots:</div>
<div class="line">    void setSource(const QString&amp; src);</div>
<div class="line"> </div>
<div class="line">signals:</div>
<div class="line">    void description(const QString&amp; desc);</div>
<div class="line"> </div>
<div class="line">};</div>
</div><!-- fragment --><p>Let's now turn to the <em>tdialread.cpp</em> file and deal with the implementation.</p>
<p>Start removing the <em>refresh</em> and <em>autoConfigure</em> methods. The old <em>qtango style constructor</em> must be removed as well, and the following code will be the starting point for the reader implementation:</p>
<div class="fragment"><div class="line">#include &quot;tdialread.h&quot;</div>
<div class="line"> </div>
<div class="line">TDialRead::TDialRead(QWidget *w, Cumbia *cumbia, const CuControlsReaderFactoryI &amp;r_fac) {</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">CuContext *TDialRead::getContext() const {</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void TDialRead::onUpdate(const CuData &amp;data){</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p>To create, connect and destroy the reader we exploit the Context class. We need a reference to it throughout the whole object's lifetime. Add a <em>context</em> class attribute in the <em>header</em> file:</p>
<div class="fragment"><div class="line">class TDialRead : public QDial, public CuDataListener, public CuContextI</div>
<div class="line">{</div>
<div class="line">    Q_OBJECT</div>
<div class="line">public:</div>
<div class="line">    // ...</div>
<div class="line">private:</div>
<div class="line">    CuContext *contex;</div>
</div><!-- fragment --><p>and instantiate it in the constructor. Return the pointer to it from the <em>getContext</em> function:</p>
<p>TDialRead::TDialRead(QWidget *w, Cumbia *cumbia, const CuControlsReaderFactoryI &amp;r_fac) : QDial(w) { context = new CuContext(cumbia, r_fac);</p>
<p>}</p>
<p>CuContext *TDialRead::getContext() const { return context; }</p>
<p>Rember to add</p>
<div class="fragment"><div class="line">#include &lt;cucontext.h&gt;</div>
</div><!-- fragment --><p>before the constructor implementation in the cpp file.</p>
<p>The purpose of the <em>qtango</em> TDialRead::autoConfigure method was to get the attribute configuration properties from the Tango database and use them to set the <em>minimum and maximum</em> on the dial. Let's do the same now in the cumbia <em>onUpdate</em> callback. After checking if no errors occurred, test whether the data that's just arrived is a <em>configuration</em> type data. Formerly, <em>qtango</em> used to pass configuration data through a specific slot with a TangoConfigurationParameters argument. Now, <em>configuration</em> and <em>actual read data</em> are delivered through the same <em>onUpdate</em> callback. To distinguish data containing database properties from data obtained from the device, we test the value stored in the <em>type key</em> within data. If it is equal to the string <em>property</em>, then configuration data has been delivered this time:</p>
<table style="width:100%">
<tr>
<th>cumbia code <br  />
 </th><th><p class="starttd">qtango code </p>
<p class="endtd"></p>
</th></tr>
<tr>
<td><div class="fragment"><div class="line">void TDialRead::onUpdate(const CuData &amp;data){</div>
<div class="line">    bool read_ok = !data[&quot;err&quot;].toBool();</div>
<div class="line">    if(read_ok) {</div>
<div class="line">        if(data[&quot;type&quot;].toString() == &quot;property&quot;) {</div>
<div class="line">            // configure!</div>
<div class="line">            double m, M;</div>
<div class="line">            if(data[&quot;min&quot;].to&lt;double&gt;(m) &amp;&amp; data[&quot;max&quot;].to&lt;double&gt;(M)) {</div>
<div class="line">                setMinimum(m);</div>
<div class="line">                setMaximum(M);</div>
<div class="line">            }</div>
<div class="line">            if(data[&quot;description&quot;].toString()</div>
<div class="line">        }</div>
<div class="line">        else {</div>
<div class="line">            int v;</div>
<div class="line">            data[&quot;value&quot;].to&lt;int&gt;(v);</div>
<div class="line">            setValue(v);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    setToolTip(QString::fromStdString(data[&quot;msg&quot;].toString()));</div>
<div class="line">    setEnabled(read_ok);</div>
</div><!-- fragment --><p class="intertd"></p>
<p class="endtd"></p>
</td><td><div class="fragment"><div class="line">void TDialRead::autoConfigure(const TangoConfigurationParameters *cp)</div>
<div class="line">{</div>
<div class="line">    if(cp-&gt;minIsSet())</div>
<div class="line">        setMinimum(cp-&gt;minValue());</div>
<div class="line">    if(cp-&gt;maxIsSet())</div>
<div class="line">        setMaximum(cp-&gt;maxValue());</div>
<div class="line"> </div>
<div class="line">    QString desc;</div>
<div class="line">    if(cp-&gt;descriptionIsSet())</div>
<div class="line">        desc = cp-&gt;description() + &quot; &quot;;</div>
<div class="line">    if(cp-&gt;displayUnitIsSet())</div>
<div class="line">        desc += &quot;[&quot; + cp-&gt;displayUnit() + &quot;]&quot;;</div>
<div class="line">    emit description(desc);</div>
<div class="line"> </div>
<div class="line">    if(cp-&gt;currentValue().canConvertToInt())</div>
<div class="line">        setValue(cp-&gt;currentValue().toInt());</div>
<div class="line">}</div>
</div><!-- fragment --><p class="intertd"></p>
<p class="intertd"></p>
<p class="endtd"></p>
</td></tr>
</table>
<p>Otherwise, if no <em>property</em> value is associated to the <em>type</em> key, we extract the read value into an integer and set it on the dial.</p>
<p>See the CuVariant class documentation for more conversion options.</p>
<p>The code above shows the new <em>cumbia</em> code (left) that does the same task as the <em>qtango</em> code on the right. In <em>qtango</em> new read data was delivered through the <em>refresh</em> slot:</p>
<div class="fragment"><div class="line">setEnabled(v.quality() != Tango::ATTR_INVALID);</div>
<div class="line">setToolTip(v.message());</div>
<div class="line">if(v.canConvertToInt())</div>
<div class="line">    setValue(v.toInt());</div>
<div class="line">else</div>
<div class="line">    setToolTip(toolTip() + &quot;\n\nWrong data type&quot;);</div>
</div><!-- fragment --><p>The two <em>source</em> and <em>setSource</em> implementations still have to be discussed. The first method returns a string with the name of the source of the reader (i.e. a Tango attribute or command). We use <em>CuControlsReader</em> from the <em>Context</em> to obtain the necessary information. Add the required <em>cucontrolsreader_abs.h include</em> file:</p>
<div class="fragment"><div class="line">#include &lt;cucontrolsreader_abs.h&gt;</div>
<div class="line"> </div>
<div class="line">// ...</div>
<div class="line"> </div>
<div class="line">QString TDialRead::source() const</div>
<div class="line">{</div>
<div class="line">    if(CuControlsReaderA* r = context-&gt;getReader())</div>
<div class="line">        return r-&gt;source();</div>
<div class="line">    return &quot;&quot;;</div>
<div class="line">}</div>
</div><!-- fragment --><p>To set (or change) a source, we rely on the <em>CuContext</em> again to obtain an <em>engine independent</em> CuControlsReaderA pointer to an abstract reader. Don't forget to call <em>setSource</em> on that object later:</p>
<div class="fragment"><div class="line">void TDialRead::setSource(const QString &amp;s)</div>
<div class="line">{</div>
<div class="line">    CuControlsReaderA * r = context-&gt;replace_reader(s.toStdString(), this);</div>
<div class="line">    if(r)</div>
<div class="line">        r-&gt;setSource(s);</div>
<div class="line">}</div>
</div><!-- fragment --><h3>Optional: provide a context menu to widgets</h3>
<p>QTango widgets extending <em>QTangoWidgetCommon</em> get some features for free; mostly, a <em>context menu</em> with some options. To benefit from a <em>context menu</em> in <em>cumbia</em>, you have to</p>
<ul>
<li>add an implementation of</li>
</ul>
<div class="fragment"><div class="line">protected:</div>
<div class="line">    void contextMenuEvent(QContextMenuEvent* e);</div>
</div><!-- fragment --><ul>
<li>declare a signal like this:</li>
</ul>
<div class="fragment"><div class="line">signals:</div>
<div class="line">    void linkStatsRequest(QWidget *myself, CuContextI *myself_as_cwi);</div>
</div><!-- fragment --><p>Within <em>contextMenuEvent</em>, place this code (<em>tdialread.cpp</em>):</p>
<div class="fragment"><div class="line">#include &lt;cucontextmenu.h&gt;</div>
<div class="line">// ...</div>
<div class="line">void TDialRead::contextMenuEvent(QContextMenuEvent *e)</div>
<div class="line">{</div>
<div class="line">    CuContextMenu* m = new CuContextMenu(this, this);</div>
<div class="line">    connect(m, SIGNAL(linkStatsTriggered(QWidget*, CuContextI *)),</div>
<div class="line">            this, SIGNAL(linkStatsRequest(QWidget*, CuContextI *)));</div>
<div class="line">    m-&gt;popup(e-&gt;globalPos());</div>
<div class="line">}</div>
</div><!-- fragment --><p>In order to update the statistics exported through the specific context menu option, you finally have to add another section within the <em>TDialRead::onUpdate</em> method:</p>
<div class="fragment"><div class="line">void TDialRead::onUpdate(const CuData &amp;data){</div>
<div class="line">    bool read_ok = !data[&quot;err&quot;].toBool();</div>
<div class="line">    if(read_ok) {</div>
<div class="line">        // update link statistics</div>
<div class="line">        d-&gt;context-&gt;getLinkStats()-&gt;addOperation();</div>
<div class="line">        if(!d-&gt;read_ok)</div>
<div class="line">            d-&gt;context-&gt;getLinkStats()-&gt;addError(da[&quot;msg&quot;].toString());</div>
<div class="line">            </div>
<div class="line">        // continue read_ok section</div>
<div class="line">        // ...</div>
</div><!-- fragment --><p>This last (optional) step completes the migration of a custom <em>qtango</em> object to <em>cumbia</em>. The same can be done equivalently for writers.</p>
<h2>Migrate QTangoComProxyWriter derived objects</h2>
<p>Inspect the code within <em>tdialwrite.h</em> under</p>
<p>*/path/to/cumbia-libs/qumbia-apps/qumbiaprojectwizard/demos/qtango_porting/complex_qtango_demo/src*</p>
<p><em>TDialWrite</em> is a writer deriving from <em>QTangoComProxyWriter</em> and <em>QTangoWidgetCommon</em>, in analogy with the <em>reader</em> already described.</p>
<div class="fragment"><div class="line">#include &lt;QDial&gt;</div>
<div class="line">#include &lt;com_proxy_writer.h&gt;</div>
<div class="line">#include &lt;qtango_wcommon.h&gt;</div>
<div class="line"> </div>
<div class="line">class TDialWrite : public QDial, public QTangoComProxyWriter, public QTangoWidgetCommon</div>
<div class="line">{</div>
<div class="line">    Q_OBJECT</div>
<div class="line">public:</div>
<div class="line">    explicit TDialWrite(QWidget *parent = nullptr);</div>
<div class="line">signals:</div>
<div class="line">    void description(const QString&amp; desc);</div>
<div class="line">protected slots:</div>
<div class="line">    void autoConfigure(const TangoConfigurationParameters *cp);</div>
<div class="line">    void write(int val);</div>
<div class="line">};</div>
</div><!-- fragment --><p>we can spot the equivalent <em>autoConfigure slot</em> and an additional <em>slot</em> that is used to write when the dial is rotated.</p>
<p>First of all, remove the <em>qtango specific includes</em> and change the constructor exactly the same way as we did for the reader. Remove also the <em>autoConfigure</em> slot, which is not necessary. As done before, make sure the necessary <em>cumbia includes</em> are placed at the beginning of the <em>header file</em>. The <em>description</em> signal and the <em>write</em> methods can be reused:</p>
<div class="fragment"><div class="line">#include &lt;QDial&gt;</div>
<div class="line">#include &lt;cudatalistener.h&gt;</div>
<div class="line">#include &lt;cucontexti.h&gt;</div>
<div class="line"> </div>
<div class="line">class Cumbia;</div>
<div class="line">class CumbiaPool;</div>
<div class="line">class CuControlsFactoryPool;</div>
<div class="line">class CuControlsWriterFactoryI;</div>
<div class="line"> </div>
<div class="line">class TDialWrite : public QDial, public QTangoComProxyWriter, public QTangoWidgetCommon</div>
<div class="line">{</div>
<div class="line">    Q_OBJECT</div>
<div class="line">public:</div>
<div class="line">    explicit TDialWrite(QWidget *parent, Cumbia *cumbia, const CuControlsWriterFactoryI &amp;w_fac);</div>
<div class="line"> </div>
<div class="line">signals:</div>
<div class="line">    void description(const QString&amp; desc);</div>
<div class="line"> </div>
<div class="line">protected slots:</div>
<div class="line">    void write(int val);</div>
<div class="line">};</div>
</div><!-- fragment --><p><em>cumbia</em>'s <em>TDialWrite</em> will derive from the very same two interfaces as <em>TDialRead</em>.</p>
<ul>
<li><em>CuDataListener</em> enables to get configuration parameters from the Tango database and to receive the outcomes of a <em>write</em> operation</li>
<li><em>CuContextI</em> interface forces to define a <em>getContext</em> method that makes the object apt to provide a <em>CuContext</em> through which to export statistics</li>
</ul>
<p>In analogy with the reader's case, we use the <em>CuContext</em> as a <em>proxy</em> object to connect to the control system and set the target. Declare a <em>CuContext</em> private attribute in the TDialWrite class definition. Inheriting from the two interfaces <em>CuDataListener and CuContextI</em> forces to implement the two methods <em>onUpdate</em> and <em>getContext</em>:</p>
<div class="fragment"><div class="line">class TDialWrite : public QDial, public CuDataListener, public CuContextI</div>
<div class="line">{</div>
<div class="line">    Q_OBJECT</div>
<div class="line">public:</div>
<div class="line">    explicit TDialWrite(QWidget *parent, Cumbia *cumbia, const CuControlsWriterFactoryI &amp;w_fac);</div>
<div class="line"> </div>
<div class="line">    // CuContextI interface</div>
<div class="line">    virtual CuContext *getContext() const;</div>
<div class="line">    // CuDataListener interface</div>
<div class="line">    virtual void onUpdate(const CuData &amp;data);</div>
<div class="line">    </div>
<div class="line">signals:</div>
<div class="line">    void description(const QString&amp; desc);</div>
<div class="line"> </div>
<div class="line">protected slots:</div>
<div class="line">    void write(int val);</div>
<div class="line"> </div>
<div class="line">private:</div>
<div class="line">    CuContext *context;</div>
<div class="line">};</div>
</div><!-- fragment --><p>In complete analogy with the reader, we need a <em>target</em> and <em>setTarget</em> method for the writer. The equivalent methods were named <em>setTargets</em> and <em>targets</em> in <em>QTango</em>. <em>QTango targets</em> allowed multiple targets on a single object. In <em>cumbia</em> this is not possible. In <em>QTango</em>, the <em>get</em> and <em>set</em> targets methods were given for free from the QTangoComProxyWriter parent class. We need to declare them amongst the other class methods in the <em>cumbia</em> version:</p>
<div class="fragment"><div class="line">class TDialWrite : public QDial, public CuDataListener, public CuContextI</div>
<div class="line">{</div>
<div class="line">    Q_OBJECT</div>
<div class="line">public:</div>
<div class="line">    //...</div>
<div class="line">    QString target() const;</div>
<div class="line">    </div>
<div class="line">    public slots:</div>
<div class="line">        void setTarget(const QString&amp; target);</div>
<div class="line">    // ...</div>
</div><!-- fragment --><h3>The writer <em>cpp</em> implementation</h3>
<p>Remove the <em>QTango</em> constructor and the <em>autoConfigure</em> method on the <em>cpp</em> implementation. Then empty the body of the <em>write</em> method. Let the <em>getContext</em> method simply return the pointer to the CuContext that will be used by this object. Replace the old constructor with the new <em>cumbia</em> TDialWrite constructor</p>
<div class="fragment"><div class="line">TDialWrite::TDialWrite(QWidget *parent, Cumbia *cumbia, const CuControlsWriterFactoryI &amp;w_fac) {</div>
<div class="line">    </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void TDialWrite::write(int val) {</div>
<div class="line">    // QTangoComProxyWriter::execute(val); &lt;-- remove this</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">CuContext *TDialWrite::getContext() const {</div>
<div class="line">    return context;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void TDialWrite::onUpdate(const CuData &amp;data) {</div>
<div class="line">}</div>
</div><!-- fragment --><p>The constructor will instantiate the <em>context</em> and connect the <em>valueChanged</em> signal of the QDial to the <em>write</em> slot, so that each time the dial is rotated, a write is performed:</p>
<div class="fragment"><div class="line">#include &quot;tdialwrite.h&quot;</div>
<div class="line">#include &lt;cucontrolswriter_abs.h&gt;</div>
<div class="line">#include &lt;cucontext.h&gt;</div>
<div class="line"> </div>
<div class="line">TDialWrite::TDialWrite(QWidget *parent, Cumbia *cumbia, const CuControlsWriterFactoryI &amp;w_fac)</div>
<div class="line">    : QDial(parent)</div>
<div class="line">{</div>
<div class="line">    context = new CuContext(cumbia, w_fac);</div>
<div class="line">    connect(this, SIGNAL(valueChanged(int)), this, SLOT(write(int)));</div>
<div class="line">}</div>
</div><!-- fragment --><p>The following code snippet shows the implementation of the <em>write</em> function. This is invoked every time the dial is rotated. This could be optimized performing the <em>write</em> operation only when the rotation finishes, but this is not the priority now. First of all notice that if <em>setTarget</em> hasn't been called, there is no CuControlsWriterA available yet (see the <em>target</em> and <em>setTarget</em> functions). That's why it is important to watch out for a <em>null</em> CuControlsWriterA pointer. If it's not <em>null</em>, set the <em>args</em> and call <em>execute</em> on it. The integer value passed to <em>write</em> is wrapped up into a <em>CuVariant</em>.</p>
<div class="fragment"><div class="line">void TDialWrite::write(int val)</div>
<div class="line">{</div>
<div class="line">    CuVariant args(val);</div>
<div class="line">    CuControlsWriterA *w = d-&gt;context-&gt;getWriter();</div>
<div class="line">    if(w) {</div>
<div class="line">        w-&gt;setArgs(args);</div>
<div class="line">        w-&gt;execute();</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <em>onUpdate</em> method can be used to configure the dial with lower and upper bounds, just as we did in the reader. It's a good idea to check that the <em>Tango attribute</em> is <em>writable</em>, disable the widget if it's not, and to initialize the value of the <em>writer</em> with the <em>Tango set point value</em>, which is associated to the <em>w_value key</em>. If the attribute description and <em>display unit</em> are available, use them (emit the <em>description signal</em>):</p>
<div class="fragment"><div class="line">void TDialWrite::onUpdate(const CuData &amp;data) {</div>
<div class="line">    bool read_ok = !data[&quot;err&quot;].toBool();</div>
<div class="line">    bool format_ok = da[&quot;data_format_str&quot;] == &quot;scalar&quot; &amp;&amp; da[&quot;writable&quot;].toInt() &gt; 0;</div>
<div class="line">    if(read_ok &amp;&amp; format_ok) {</div>
<div class="line">        QString desc;</div>
<div class="line">        if(data[&quot;type&quot;].toString() == &quot;property&quot;) {</div>
<div class="line">            // configure!</div>
<div class="line">            double m, M;</div>
<div class="line">            if(data[&quot;min&quot;].to&lt;double&gt;(m) &amp;&amp; data[&quot;max&quot;].to&lt;double&gt;(M)) {</div>
<div class="line">                setMinimum(m);</div>
<div class="line">                setMaximum(M);</div>
<div class="line">            }</div>
<div class="line">            if(data[&quot;description&quot;].toString().size())</div>
<div class="line">                desc = QString::fromStdString(data[&quot;description&quot;].toString());</div>
<div class="line">            if(data[&quot;display_unit&quot;].toString().size())</div>
<div class="line">                desc += &quot; [&quot; + QString::fromStdString(data[&quot;display_unit&quot;].toString()) + &quot;]&quot;;</div>
<div class="line">            if(!desc.isEmpty())</div>
<div class="line">                emit description(desc);</div>
<div class="line">        }</div>
<div class="line">        else {</div>
<div class="line">            int v;</div>
<div class="line">            data[&quot;w_value&quot;].to&lt;int&gt;(v);</div>
<div class="line">            setValue(v);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    else if(!format_ok)</div>
<div class="line">        setToolTip(&quot;the data format of &quot; + QString::fromStdString(data[&quot;src&quot;].toString()) + &quot; is not scalar or not writable&quot;);</div>
<div class="line">    else</div>
<div class="line">        setToolTip(QString::fromStdString(data[&quot;msg&quot;].toString()));</div>
<div class="line"> </div>
<div class="line">    setEnabled(read_ok &amp;&amp; format_ok);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Finally, write the implementation of <em>target</em> and <em>setTarget</em> in the <em>cpp</em> file:</p>
<div class="fragment"><div class="line">QString TDialWrite::target() const</div>
<div class="line">{</div>
<div class="line">    CuControlsWriterA *w = d-&gt;context-&gt;getWriter();</div>
<div class="line">    if(w != NULL)</div>
<div class="line">        return w-&gt;target();</div>
<div class="line">    return &quot;&quot;;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void TDialWrite::setTarget(const QString &amp;targets)</div>
<div class="line">{</div>
<div class="line">    CuControlsWriterA* w = d-&gt;context-&gt;replace_writer(targets.toStdString(), this);</div>
<div class="line">    if(w) w-&gt;setTarget(targets);</div>
<div class="line">}</div>
</div><!-- fragment --><p>It's now time to try to build the <em>complex project</em>. Open a terminal into the</p>
<p>*/path/to/cumbia-libs/qumbia-apps/qumbiaprojectwizard/demos/qtango_porting/complex_qtango_demo/src*</p>
<p>directory and execute</p>
<div class="fragment"><div class="line">cuuimake --pre-clean --qmake</div>
</div><!-- fragment --><p>The picture below shows the output of the <em>cuuimake</em> utility. It detected two <em>custom classes</em> that <em>are</em> cumbia objects:</p>
<ul>
<li>TDialRead</li>
<li>TDialWrite</li>
</ul>
<p>Definitions are automatically added by <em>cuuimake</em> so that <em>expansion</em> takes place for both classes <em>just as if</em> they were part of the <em>cumbia-qtcontrols</em> library.</p>
<div class="image">
<img src="cuuimake-output2.png" alt=""/>
<div class="caption">
cuuimake: process the cumbia project and auto detect custom classes</div></div>
 <h2>Final steps of the <em>complex project</em> porting recipe</h2>
<p>The <em>complex project</em> under examination is made up of <em>two ui</em> files and <em>two classes</em> that respectively use the forms defined in the <em>ui</em> files:</p>
<div class="fragment"><div class="line">cd /path/to/cumbia-libs/qumbia-apps/qumbiaprojectwizard/demos/qtango_porting/complex_qtango_demo/src</div>
<div class="line">ls</div>
</div><!-- fragment --><div class="image">
<img src="ls_src.png" alt=""/>
<div class="caption">
list of the complex qtango sources</div></div>
 <p>There we can find</p>
<ul>
<li>The main widget class defined in <em>ComplexQTangoDemo.h</em> and <em>ComplexQTangoDemo.cpp</em>. Form described in <em>ComplexQTangoDemo.ui</em></li>
<li>A dialog window class defined in <em>demodialog.h</em> and <em>demodialog.cpp</em>. Form described in <em>demodialog.ui</em></li>
</ul>
<p>The <em>qumbiaprojectwizard</em> is targeted to porting a <em>simple</em> project with a <em>main widget</em> class with one <em>ui</em> form. The utility reads the <em>main.cpp</em>, finds the candidate <em>main widget class name</em> and scans the other source files in order to find its definition. For this reason, <em>ComplexQTangoDemo.h</em>, <em>ComplexQTangoDemo.cpp</em> and <em>ComplexQTangoDemo.ui</em> can be ported automatically also in this <em>complex example</em>.</p>
<p>On the other hand <em>*demodialog.h*, <em>demodialog.cpp</em> and <em>demodialog.ui</em> need further attention</em>. Actually, <em>demodialog.ui</em> is processed and the <em>QTango</em> classes have been replaced by their <em>cumbia</em> counterparts. When <em>cuuimake</em> processes <em>demodialog.ui</em>, finds <em>cumbia</em> classes within the <em>ui_demodialog.h</em> file generated by <em>uic</em>, the Qt <em>ui</em> compiler. They are expanded. For example, if you open <em>ui_demodialog.ui</em> you will find lines like this:</p>
<div class="fragment"><div class="line">tPlotLightMarker = new QuTrendPlot(DemoDialog, cu_t, cu_tango_r_fac);</div>
<div class="line">tPlotLightMarker-&gt;setObjectName(QStringLiteral(&quot;tPlotLightMarker&quot;));</div>
</div><!-- fragment --><p>This means that QuTrendPlot has been correctly instantiated with the additional <em>cumbia</em> parameters. The <em>void setupUi</em> method definition has been also expanded by <em>cuuimake</em>:</p>
<div class="fragment"><div class="line">void setupUi(QDialog *DemoDialog, CumbiaTango *cu_t, const CuTReaderFactory&amp; cu_tango_r_fac, const CuTWriterFactory&amp; cu_tango_w_fac)</div>
</div><!-- fragment --><h3>Port <em>demodialog.h</em> header file</h3>
<p>As previously mentioned, <em>demodialog.h</em> has not been processed by <em>qumbiaprojectwizard</em>, because it is not the <em>main widget</em> class of a simple project.</p>
<p>You have to do this manually, and it is very simple indeed. It's enough to make it look exactly like <em>ComplexQTangoDemo.h</em>! (include files and additional <em>private class members</em>)</p>
<p>Open <em>ComplexQTangoDemo.h</em> and copy the <em>two</em> sections delimited by</p>
<div class="fragment"><div class="line">// cumbia-tango</div>
<div class="line">...</div>
<div class="line">// cumbia-tango</div>
</div><!-- fragment --><p>to the <em>demodialog.h</em>, <em>exactly in the same position as they are in ComplexQTangoDemo.h</em>. Then <em>expand</em> the constructor definition adding the <em>CumbiaTango</em> parameter. The modified version will look like this:</p>
<div class="fragment"><div class="line">#ifndef DEMODIALOG_H</div>
<div class="line">#define DEMODIALOG_H</div>
<div class="line"> </div>
<div class="line">// cumbia-tango                  &lt;--  first cumbia-tango section, copied from ComplexQTangoDemo.h</div>
<div class="line">#include &lt;qulogimpl.h&gt;</div>
<div class="line">#include &lt;cutcontrolsreader.h&gt;</div>
<div class="line">#include &lt;cutcontrolswriter.h&gt;</div>
<div class="line">#include &lt;cumbiatango.h&gt;</div>
<div class="line">// cumbia-tango                  &lt;--  end of first cumbia-tango section</div>
<div class="line"> </div>
<div class="line">#include &lt;QDialog&gt;</div>
<div class="line"> </div>
<div class="line">namespace Ui {</div>
<div class="line">class DemoDialog;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">class DemoDialog : public QDialog</div>
<div class="line">{</div>
<div class="line">    Q_OBJECT</div>
<div class="line"> </div>
<div class="line">public:</div>
<div class="line">    explicit DemoDialog(CumbiaTango *cut, QWidget *parent = 0);  // </div>
<div class="line">    ~DemoDialog();</div>
<div class="line"> </div>
<div class="line">private:</div>
<div class="line">    Ui::DemoDialog *ui;                       // &lt;-- this is already ok!</div>
<div class="line"> </div>
<div class="line">    // cumbia-tango                            &lt;--  second cumbia-tango section, copied from ComplexQTangoDemo.h</div>
<div class="line">        CumbiaTango *cu_t;</div>
<div class="line">        CuTReaderFactory cu_tango_r_fac;</div>
<div class="line">        CuTWriterFactory cu_tango_w_fac;</div>
<div class="line">        QuLogImpl m_log_impl;</div>
<div class="line">        CuLog *m_log;</div>
<div class="line">    // cumbia-tango                            &lt;--  end of second cumbia-tango section</div>
<div class="line">};  </div>
<div class="line"> </div>
<div class="line">#endif // DEMODIALOG_H</div>
</div><!-- fragment --><p>Please note that the declaration:</p>
<div class="fragment"><div class="line">Ui::DemoDialog *ui;</div>
</div><!-- fragment --><p>already implies the instantiation of <em>Ui::DemoDialog</em> in the <em>heap</em>, which is required in <em>cumbia</em>.</p>
<p>The mofified code adds the necessary <em>cumbia specific</em> class attributes and the needed <em>include files</em>.</p>
<h3>Port <em>demodialog.cpp</em> cpp file</h3>
<p>As explained before, the <em>setupUi</em> method has been expanded by <em>cuuimake</em> in <em>ui_demodialog.h</em> like this:</p>
<div class="fragment"><div class="line">void setupUi(QDialog *DemoDialog, CumbiaTango *cu_t, const CuTReaderFactory&amp; cu_tango_r_fac, const CuTWriterFactory&amp; cu_tango_w_fac) </div>
<div class="line">{</div>
<div class="line"> // ... in </div>
<div class="line">}</div>
</div><!-- fragment --><p>What you have to do is open the <em>demodialog.cpp</em>, change the constructor from</p>
<div class="fragment"><div class="line">DemoDialog::DemoDialog(QWidget *parent) :</div>
<div class="line">    QDialog(parent),</div>
<div class="line">    ui(new Ui::DemoDialog)</div>
</div><!-- fragment --><p>to</p>
<div class="fragment"><div class="line">DemoDialog::DemoDialog(CumbiaTango *cut, QWidget *parent) :</div>
<div class="line">    QDialog(parent)</div>
</div><!-- fragment --><p>as defined in the <em>demodialog.h</em>.</p>
<p>Then, copy the <em>CumbiaTango pointer</em> into the <em>cu_t</em> class attribute and complete the paramters to <em>setupUi</em> so that they match the ones defined in <em>ui_demodialog.h</em>.</p>
<p>From:</p>
<div class="fragment"><div class="line">ui-&gt;setupUi(this);</div>
</div><!-- fragment --><p>to:</p>
<div class="fragment"><div class="line">cu_t = cut;</div>
<div class="line">ui-&gt;setupUi(this, cut, cu_tango_r_fac, cu_tango_w_fac);</div>
</div><!-- fragment --><p>Optional code can be copied from the <em>ComplexQTangoDemo</em> constructor in <em>ComplexQTangoDemo.cpp</em> if you want to add the <em>logging facility</em> and allow the <em>cumbia widgets</em> to provide a context menu.</p>
<p>Since the <em>DemoDialog</em> constructor accepts now two parameters (not only the parent QWidget as before), we must locate where in the project the <em>DemoDialog</em> is instantiated. We can easily spot that this occurs in the <em>ComplexQTangoDemo.cpp</em> file:</p>
<div class="fragment"><div class="line">void ComplexQTangoDemo::execDemoDialog()</div>
<div class="line">{</div>
<div class="line">    DemoDialog dd(this);</div>
<div class="line">    dd.exec();</div>
<div class="line">}</div>
</div><!-- fragment --><p>The new code will be:</p>
<div class="fragment"><div class="line">void ComplexQTangoDemo::execDemoDialog()</div>
<div class="line">{</div>
<div class="line">    DemoDialog dd(cu_t, this);</div>
<div class="line">    dd.exec();</div>
<div class="line">}</div>
</div><!-- fragment --><p>where cu_t is a pointer to <em>CumbiaTango</em>, passed from the <em>main.cpp</em> into the <em>main widget class constructor</em>.</p>
<p>Congratulations! If you carefully followed these instructions and thoroughly understood all the steps, the project should now build successfully and work! </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 29 2021 16:20:58 for qumbia-tango-controls by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
