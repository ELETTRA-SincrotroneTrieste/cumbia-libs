<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cumbia-qtcontrols: QuMultiReaderPluginInterface Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cumbia-qtcontrols
   &#160;<span id="projectnumber">1.x</span>
   </div>
   <div id="projectbrief">Qt widgets on top of the cumbia C++ library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classQuMultiReaderPluginInterface-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">QuMultiReaderPluginInterface Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__plugins.html">Plugins</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Interface for a plugin implementing reader that connects to multiple quantities.  
 <a href="classQuMultiReaderPluginInterface.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="qumultireaderplugininterface_8h_source.html">qumultireaderplugininterface.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aed31d667e7aba03274eb114ac230e5b8"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuMultiReaderPluginInterface.html#aed31d667e7aba03274eb114ac230e5b8">~QuMultiReaderPluginInterface</a> ()</td></tr>
<tr class="separator:aed31d667e7aba03274eb114ac230e5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011a95939b85257fb109ed911a1996ee"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuMultiReaderPluginInterface.html#a011a95939b85257fb109ed911a1996ee">init</a> (Cumbia *cumbia, const <a class="el" href="classCuControlsReaderFactoryI.html">CuControlsReaderFactoryI</a> &amp;r_fac, int manual_mode_code)=0</td></tr>
<tr class="memdesc:a011a95939b85257fb109ed911a1996ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise the multi reader with the desired engine and the read mode.  <a href="#a011a95939b85257fb109ed911a1996ee">More...</a><br /></td></tr>
<tr class="separator:a011a95939b85257fb109ed911a1996ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e04a4812265a9345f9460137c242fe"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuMultiReaderPluginInterface.html#aa4e04a4812265a9345f9460137c242fe">init</a> (CumbiaPool *cumbia_pool, const <a class="el" href="classCuControlsFactoryPool.html">CuControlsFactoryPool</a> &amp;fpool, int manual_mode_code)=0</td></tr>
<tr class="memdesc:aa4e04a4812265a9345f9460137c242fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise the multi reader with mixed engine mode and the read mode.  <a href="#aa4e04a4812265a9345f9460137c242fe">More...</a><br /></td></tr>
<tr class="separator:aa4e04a4812265a9345f9460137c242fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669db262e60a8d5ee0f1d2c5084257e5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuMultiReaderPluginInterface.html#a669db262e60a8d5ee0f1d2c5084257e5">setSources</a> (const QStringList &amp;srcs)=0</td></tr>
<tr class="memdesc:a669db262e60a8d5ee0f1d2c5084257e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the sources to read from.  <a href="#a669db262e60a8d5ee0f1d2c5084257e5">More...</a><br /></td></tr>
<tr class="separator:a669db262e60a8d5ee0f1d2c5084257e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb2347a7d6ebcacddc1e63470a7b939"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuMultiReaderPluginInterface.html#a5eb2347a7d6ebcacddc1e63470a7b939">unsetSources</a> ()=0</td></tr>
<tr class="memdesc:a5eb2347a7d6ebcacddc1e63470a7b939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the readers.  <a href="#a5eb2347a7d6ebcacddc1e63470a7b939">More...</a><br /></td></tr>
<tr class="separator:a5eb2347a7d6ebcacddc1e63470a7b939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8cdb9711a756f7c9688703ad2f70680"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuMultiReaderPluginInterface.html#af8cdb9711a756f7c9688703ad2f70680">insertSource</a> (const QString &amp;src, int i=-1)=0</td></tr>
<tr class="memdesc:af8cdb9711a756f7c9688703ad2f70680"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a source to the multi reader.  <a href="#af8cdb9711a756f7c9688703ad2f70680">More...</a><br /></td></tr>
<tr class="separator:af8cdb9711a756f7c9688703ad2f70680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8b66fea0b2cbc9d52cdd1c58ad0263"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuMultiReaderPluginInterface.html#ace8b66fea0b2cbc9d52cdd1c58ad0263">removeSource</a> (const QString &amp;src)=0</td></tr>
<tr class="memdesc:ace8b66fea0b2cbc9d52cdd1c58ad0263"><td class="mdescLeft">&#160;</td><td class="mdescRight">removes the specified source from the reader  <a href="#ace8b66fea0b2cbc9d52cdd1c58ad0263">More...</a><br /></td></tr>
<tr class="separator:ace8b66fea0b2cbc9d52cdd1c58ad0263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe4c3c1bcf70e1b5f244b616d459f97"><td class="memItemLeft" align="right" valign="top">virtual QStringList&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuMultiReaderPluginInterface.html#a6fe4c3c1bcf70e1b5f244b616d459f97">sources</a> () const =0</td></tr>
<tr class="memdesc:a6fe4c3c1bcf70e1b5f244b616d459f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the list of the configured sources  <a href="#a6fe4c3c1bcf70e1b5f244b616d459f97">More...</a><br /></td></tr>
<tr class="separator:a6fe4c3c1bcf70e1b5f244b616d459f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e9b4be50a8100a24764d8565d64f981"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuMultiReaderPluginInterface.html#a3e9b4be50a8100a24764d8565d64f981">period</a> () const =0</td></tr>
<tr class="memdesc:a3e9b4be50a8100a24764d8565d64f981"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the polling period of the reader.  <a href="#a3e9b4be50a8100a24764d8565d64f981">More...</a><br /></td></tr>
<tr class="separator:a3e9b4be50a8100a24764d8565d64f981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b13efebf7c9dfb05a92fa7679ff786"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuMultiReaderPluginInterface.html#a39b13efebf7c9dfb05a92fa7679ff786">setPeriod</a> (int ms)=0</td></tr>
<tr class="memdesc:a39b13efebf7c9dfb05a92fa7679ff786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the reading period, if the reading mode is sequential.  <a href="#a39b13efebf7c9dfb05a92fa7679ff786">More...</a><br /></td></tr>
<tr class="separator:a39b13efebf7c9dfb05a92fa7679ff786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d2add6fbcaf7210750c3551e712034"><td class="memItemLeft" align="right" valign="top">virtual const QObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQuMultiReaderPluginInterface.html#ae5d2add6fbcaf7210750c3551e712034">get_qobject</a> () const =0</td></tr>
<tr class="memdesc:ae5d2add6fbcaf7210750c3551e712034"><td class="mdescLeft">&#160;</td><td class="mdescRight">To provide the necessary signals aforementioned, the implementation must derive from Qt QObject. This method returns the subclass as a QObject, so that the client can connect to the multi reader signals.  <a href="#ae5d2add6fbcaf7210750c3551e712034">More...</a><br /></td></tr>
<tr class="separator:ae5d2add6fbcaf7210750c3551e712034"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interface for a plugin implementing reader that connects to multiple quantities. </p>
<ul>
<li>Readings can be sequential or parallel (see the init method). Sequential readings must notify when a reading is performed and when a complete read cycle is over, providing the read data through two Qt signals: onNewData(const CuData&amp; da) and onSeqReadComplete(const QList&lt;CuData &gt;&amp; data). Parallel readings must notify only when a new result is available, emitting the onNewData signal.</li>
</ul>
<ul>
<li>A multi reader must be initialised with the init method, that determines what is the engine used to read and whether the reading is sequential or parallel by means of the read_mode parameter. If the manual_mode_code is negative, the reading is parallel and the refresh mode is determined by the controls factory, as usual. If the manual_mode_code is non negative <em>it must correspond to the <b>manual refresh mode</b> of the underlying engine.</em> For example, CuTReader::Manual must be specified for the Tango control system engine in order to let the multi reader use an internal poller to read the attributes sequentially. </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aed31d667e7aba03274eb114ac230e5b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed31d667e7aba03274eb114ac230e5b8">&#9670;&nbsp;</a></span>~QuMultiReaderPluginInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual QuMultiReaderPluginInterface::~QuMultiReaderPluginInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae5d2add6fbcaf7210750c3551e712034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d2add6fbcaf7210750c3551e712034">&#9670;&nbsp;</a></span>get_qobject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const QObject* QuMultiReaderPluginInterface::get_qobject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To provide the necessary signals aforementioned, the implementation must derive from Qt QObject. This method returns the subclass as a QObject, so that the client can connect to the multi reader signals. </p>
<dl class="section return"><dt>Returns</dt><dd>The object implementing <a class="el" href="classQuMultiReaderPluginInterface.html" title="Interface for a plugin implementing reader that connects to multiple quantities.">QuMultiReaderPluginInterface</a> as a QObject. </dd></dl>

</div>
</div>
<a id="a011a95939b85257fb109ed911a1996ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a011a95939b85257fb109ed911a1996ee">&#9670;&nbsp;</a></span>init() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void QuMultiReaderPluginInterface::init </td>
          <td>(</td>
          <td class="paramtype">Cumbia *&#160;</td>
          <td class="paramname"><em>cumbia</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCuControlsReaderFactoryI.html">CuControlsReaderFactoryI</a> &amp;&#160;</td>
          <td class="paramname"><em>r_fac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>manual_mode_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialise the multi reader with the desired engine and the read mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cumbia</td><td>a reference to the cumbia implementation </td></tr>
    <tr><td class="paramname">r_fac</td><td>the engine reader factory </td></tr>
    <tr><td class="paramname">manual_mode_code</td><td>the value to be passed to the reading engine in order to make it work in manual mode (no polling, no event refresh mode) and perform sequential reads or a negative number to work in parallel mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4e04a4812265a9345f9460137c242fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e04a4812265a9345f9460137c242fe">&#9670;&nbsp;</a></span>init() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void QuMultiReaderPluginInterface::init </td>
          <td>(</td>
          <td class="paramtype">CumbiaPool *&#160;</td>
          <td class="paramname"><em>cumbia_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCuControlsFactoryPool.html">CuControlsFactoryPool</a> &amp;&#160;</td>
          <td class="paramname"><em>fpool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>manual_mode_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialise the multi reader with mixed engine mode and the read mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cumbia</td><td>a reference to the CumbiaPool engine chooser </td></tr>
    <tr><td class="paramname">r_fac</td><td>the <a class="el" href="classCuControlsFactoryPool.html" title="this class, used in conjunction with CumbiaPool allows to connect to different control system framewo...">CuControlsFactoryPool</a> factory chooser </td></tr>
    <tr><td class="paramname">manual_mode_code</td><td>the value to be passed to the reading engine in order to make it work in manual mode (no polling, no event refresh mode) and perform sequential reads or a negative number to work in parallel mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8cdb9711a756f7c9688703ad2f70680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8cdb9711a756f7c9688703ad2f70680">&#9670;&nbsp;</a></span>insertSource()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void QuMultiReaderPluginInterface::insertSource </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>adds a source to the multi reader. </p>
<p>Inserts src at index position i in the list. If i &lt;= 0, src is prepended to the list. If i &gt;= size(), src is appended to the list.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classQuMultiReaderPluginInterface.html#a669db262e60a8d5ee0f1d2c5084257e5" title="set the sources to read from.">setSources</a> </dd></dl>

</div>
</div>
<a id="a3e9b4be50a8100a24764d8565d64f981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e9b4be50a8100a24764d8565d64f981">&#9670;&nbsp;</a></span>period()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int QuMultiReaderPluginInterface::period </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the polling period of the reader. </p>
<dl class="section return"><dt>Returns</dt><dd>the polling period, in milliseconds, of the multi reader. </dd></dl>

</div>
</div>
<a id="ace8b66fea0b2cbc9d52cdd1c58ad0263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace8b66fea0b2cbc9d52cdd1c58ad0263">&#9670;&nbsp;</a></span>removeSource()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void QuMultiReaderPluginInterface::removeSource </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>removes the specified source from the reader </p>

</div>
</div>
<a id="a39b13efebf7c9dfb05a92fa7679ff786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39b13efebf7c9dfb05a92fa7679ff786">&#9670;&nbsp;</a></span>setPeriod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void QuMultiReaderPluginInterface::setPeriod </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the reading period, if the reading mode is sequential. </p>
<dl class="section note"><dt>Note</dt><dd>If the reading mode is parallel, the request is forwarded to every single reader. </dd></dl>

</div>
</div>
<a id="a669db262e60a8d5ee0f1d2c5084257e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a669db262e60a8d5ee0f1d2c5084257e5">&#9670;&nbsp;</a></span>setSources()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void QuMultiReaderPluginInterface::setSources </td>
          <td>(</td>
          <td class="paramtype">const QStringList &amp;&#160;</td>
          <td class="paramname"><em>srcs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the sources to read from. </p>
<dl class="section note"><dt>Note</dt><dd>Calling this method replaces the existing sources with the new ones</dd></dl>
<dl class="section see"><dt>See also</dt><dd>addSource </dd></dl>

</div>
</div>
<a id="a6fe4c3c1bcf70e1b5f244b616d459f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fe4c3c1bcf70e1b5f244b616d459f97">&#9670;&nbsp;</a></span>sources()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual QStringList QuMultiReaderPluginInterface::sources </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the list of the configured sources </p>

</div>
</div>
<a id="a5eb2347a7d6ebcacddc1e63470a7b939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eb2347a7d6ebcacddc1e63470a7b939">&#9670;&nbsp;</a></span>unsetSources()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void QuMultiReaderPluginInterface::unsetSources </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the readers. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="qumultireaderplugininterface_8h_source.html">qumultireaderplugininterface.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Dec 3 2019 14:20:14 for cumbia-qtcontrols by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
