<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cumbia-tango: Writing an activity to read Tango device, attribute and class properties</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cumbia-tango
   &#160;<span id="projectnumber">1.x</span>
   </div>
   <div id="projectbrief">C++ multi threaded library based on cumbia and the Tango control system</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Writing an activity to read <a class="el" href="namespaceTango.html">Tango</a> device, attribute and class properties </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this tutorial, we will learn how to write an activity to read <a class="el" href="namespaceTango.html">Tango</a> attribute, device and class properties from the <a class="el" href="namespaceTango.html">Tango</a> database. The example discussed here makes already part of the library, but it can be used to create custom activities to automate operations or to simply understand how to write <em>activities</em>.</p>
<p>We need to recall cumbia CuActivity concepts and will be inspired by <a class="el" href="classCuTReader.html" title="Low level class to read tango attributes and commands with output arguments.">CuTReader</a> implementation.</p>
<p><a class="el" href="classCuTReader.html" title="Low level class to read tango attributes and commands with output arguments.">CuTReader</a> implements the <a class="el" href="classCuTangoActionI.html" title="an interface for a Tango action, typically a reader or a writer are implementors">CuTangoActionI</a> interface, which in turn derives from CuThreadListener so as to force subclasses to provide the</p>
<ul>
<li>CuThreadListener::onProgress </li>
<li>CuThreadListener::onResult </li>
<li>CuThreadListener::getToken</li>
</ul>
<p>methods. <a class="el" href="classCuTReader.html" title="Low level class to read tango attributes and commands with output arguments.">CuTReader</a> inherits from the <a class="el" href="classCuTangoActionI.html" title="an interface for a Tango action, typically a reader or a writer are implementors">CuTangoActionI</a> interface in order to integrate with <a class="el" href="classCumbiaTango.html">CumbiaTango</a> and the <em>action factory</em> service, that allows to provide a <em>per device</em> thread organisation. Since in our case we deal with database properties, we choose a different approach, since not every action has to do with a device (for example, a class property is not related to a device).</p>
<p>With <em>qtcreator</em>, we add a new C++ class, name it <a class="el" href="classCuTDbPropertyReader.html" title="Read Tango device, attribute and class properties.">CuTDbPropertyReader</a> and let it inherit from the CuThreadListener interface. Once the file is created and opened in the editor, right click on the <a class="el" href="classCuTDbPropertyReader.html" title="Read Tango device, attribute and class properties.">CuTDbPropertyReader</a> class definition, choose <em>refactor</em> and then <em>Insert virtual functions of base classes</em>.</p>
<p>The <a class="el" href="cutdbpropertyreader_8h.html">cutdbpropertyreader.h</a> file will look like this:</p>
<div class="fragment"><div class="line">#ifndef CUTDBPROPERTYREADER_H</div><div class="line">#define CUTDBPROPERTYREADER_H</div><div class="line"></div><div class="line">#include &lt;cuthreadlistener.h&gt;.h&gt;</div><div class="line"></div><div class="line">class CuTDbPropertyReader : public CuThreadListener</div><div class="line">{</div><div class="line">public:</div><div class="line">    CuTDbPropertyReader();</div><div class="line">    virtual ~CuTDbPropertyReader();</div><div class="line"></div><div class="line">    // CuThreadListener interface</div><div class="line">public:</div><div class="line">    void onProgress(int step, int total, const CuData &amp;data);</div><div class="line">    void onResult(const CuData &amp;data);</div><div class="line">    CuData getToken() const;</div><div class="line">};</div><div class="line"></div><div class="line">#endif // CUTDBPROPERTYREADER_H</div></div><!-- fragment --><p>Right clicking on every method definition, let qtcreator create empty bodies for each function.</p>
<h3>Note</h3>
<p><a class="el" href="classCuTDbPropertyReader.html" title="Read Tango device, attribute and class properties.">CuTDbPropertyReader</a> will be a proxy to the <em>activity</em> fetching the data from the database, so that clients do not have to directly deal with the activity.</p>
<p><a class="el" href="classCuTangoActionI.html" title="an interface for a Tango action, typically a reader or a writer are implementors">CuTangoActionI</a> <em>Type</em> enum defines a few fundamental types of actions that can be implemented. We will use the <em>DbReadProp</em>.</p>
<div class="fragment"><div class="line">CuTangoActionI::Type CuTDbPropertyReader::getType() const</div><div class="line">{</div><div class="line">    return CuTangoActionI::DbReadProp;</div><div class="line">}</div></div><!-- fragment --><h3>Bridge pattern</h3>
<p>Let's adopt the <em>bridge</em> pattern, also known as <em>d</em> private pointer by the Qt developers, so that <a class="el" href="classCuTDbPropertyReader.html" title="Read Tango device, attribute and class properties.">CuTDbPropertyReader</a> can be extended in the future without causing troubles to binary compatibility. To accomplish this, add the line</p>
<div class="fragment"><div class="line">class CuTDbPropertyReaderPrivate;</div></div><!-- fragment --><p>at the top of the header file and the d private class attribute:</p>
<div class="fragment"><div class="line">private:</div><div class="line">    CuTDbPropertyReaderPrivate *d;</div></div><!-- fragment --><p>Let's move to the CPP file, define the private class and don't forget to allocate it in the constructor. We need to include some header files to provide needed definitions. <em>cumbia</em> library provides an object that bundles keys to values: CuData. We can use it to provide a list of database device, attribute or class properties that we want to fetch, <em>in_props</em>. A set of CuDataListener objects is stored within the <em>listeners</em> variable.</p>
<div class="fragment"><div class="line">#include &quot;cutdbpropertyreader.h&quot;</div><div class="line">#include &lt;set&gt;</div><div class="line">#include &lt;list&gt;</div><div class="line">#include &lt;cudatalistener.h&gt;</div><div class="line">#include &lt;cuserviceprovider.h&gt;</div><div class="line">#include &lt;culog.h&gt;</div><div class="line">#include &lt;cuactivity.h&gt;</div><div class="line">#include &lt;cumbiatango.h&gt;</div><div class="line"></div><div class="line">class CuTDbPropertyReaderPrivate</div><div class="line">{</div><div class="line">public:</div><div class="line">    std::set&lt;CuDataListener *&gt; listeners;</div><div class="line">    std::list&lt;CuData&gt; in_props;</div><div class="line">    std::string id;</div><div class="line">    CumbiaTango *cumbia_t;</div><div class="line">    CuGetTDbPropActivity *activity;</div><div class="line">    bool exit;</div><div class="line">    CuConLogImpl li;</div><div class="line">    CuLog log;</div><div class="line">};</div></div><!-- fragment --><p><em>cumbia</em> is a reference to the <a class="el" href="classCumbiaTango.html">CumbiaTango</a> engine. Cumbia base would be enough for this simple case, where there's no thread sharing across different instances of <a class="el" href="classCuTDbPropertyReader.html" title="Read Tango device, attribute and class properties.">CuTDbPropertyReader</a>. Nonetheless, since every cumbia application connecting to <a class="el" href="namespaceTango.html">Tango</a> instantiates <a class="el" href="classCumbiaTango.html">CumbiaTango</a>, we use it because methods to provide the thread factory and the event bridge in use (see Cumbia::registerActivity comments below).</p>
<h3>The class constructor.</h3>
<p><a class="el" href="classCuTDbPropertyReader.html" title="Read Tango device, attribute and class properties.">CuTDbPropertyReader</a> must grab a reference to Cumbia and a list of desired database properties must be provided at some time. We decide to pass the Cumbia reference in the constructor, together with an <em>id</em> that will identify every <a class="el" href="classCuTDbPropertyReader.html" title="Read Tango device, attribute and class properties.">CuTDbPropertyReader</a> used in the application (see "Registering *CuGetTDbPropActivity* with Cumbia" paragraph). We provide the list of desired properties in the <em>get</em> method instead.</p>
<p>An additional method called addListener is added in order to let objects implementing CuDataListener receive new data from the worker thread.</p>
<div class="fragment"><div class="line">#include &lt;list&gt;</div><div class="line"></div><div class="line">class CuTDbPropertyReaderPrivate;</div><div class="line">class Cumbia;</div><div class="line"></div><div class="line">class CuTDbPropertyReader : public CuThreadListener</div><div class="line">{</div><div class="line">public:</div><div class="line">    CuTDbPropertyReader(const std::string&amp; id, Cumbia *cumbia);</div><div class="line"></div><div class="line">    void get(const std::list&lt;CuData&gt;&amp; in_data);</div><div class="line">    </div><div class="line">    void addListener(CuDataListener *l);</div><div class="line">    </div><div class="line">    //...</div></div><!-- fragment --><p>In the .cpp:</p>
<div class="fragment"><div class="line">CuTDbPropertyReader::CuTDbPropertyReader(const std::string &amp;id, CumbiaTango *cumbia)</div><div class="line">{</div><div class="line">    d = new CuTDbPropertyReaderPrivate;</div><div class="line">    d-&gt;cumbia_t = cumbia;</div><div class="line">    d-&gt;id = id;</div><div class="line">}</div><div class="line"></div><div class="line">void CuTDbPropertyReader::get(const std::list&lt;CuData&gt; &amp;in_data)</div><div class="line">{</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line">void CuTDbPropertyReader::addListener(CuDataListener *l)</div><div class="line">{</div><div class="line">    d-&gt;listeners.insert(l);</div><div class="line">}</div></div><!-- fragment --><h3>The class destructor</h3>
<p>Don't forget to delete the d pointer in the destructor: </p><div class="fragment"><div class="line">CuTDbPropertyReader::~CuTDbPropertyReader()</div><div class="line">{</div><div class="line">    delete d;</div><div class="line">}</div></div><!-- fragment --><p>The <em>get</em> method accept a list of desired properties and fetches them from the <a class="el" href="namespaceTango.html">Tango</a> database. We need a <em>cumbia activity</em>, an implementation of <em>CuActivity</em>, to carry out the task in a separate thread and post the result through the <em>onResult</em> method of <a class="el" href="classCuTDbPropertyReader.html" title="Read Tango device, attribute and class properties.">CuTDbPropertyReader</a>. Let's call it <em><a class="el" href="classCuGetTDbPropActivity.html" title="an activity to get properties from the Tango database">CuGetTDbPropActivity</a></em>, that stands for *(cumbia) get <a class="el" href="namespaceTango.html">Tango</a> database property activity. It implements CuActivity. With the help of <em>qtcreator</em>, add a new class with that name. Then, as we did before, add necessary includes and virtual method definitions (.h) and implementation (.cpp). We like to have a D pointer store the private fields of the class, as we did before.</p>
<h4>getdbpropactivity.h</h4>
<div class="fragment"><div class="line">#ifndef GETTDBPROPACTIVITY_H</div><div class="line">#define GETTDBPROPACTIVITY_H</div><div class="line"></div><div class="line">#include &lt;cuactivity.h&gt;</div><div class="line">#include &lt;list&gt;</div><div class="line"></div><div class="line">class CuGetTDbPropActivityPrivate;</div><div class="line"></div><div class="line">class CuGetTDbPropActivity : public CuActivity</div><div class="line">{</div><div class="line">public:</div><div class="line">    CuGetTDbPropActivity(const std::list&lt;CuData&gt; &amp;in_data);</div><div class="line">    virtual ~CuGetTDbPropActivity(); // class destructor: delete the D pointer!</div><div class="line">    </div><div class="line">    // CuActivity interface</div><div class="line">public:</div><div class="line">    int getType() const;</div><div class="line">    void event(CuActivityEvent *e);</div><div class="line">    bool matches(const CuData &amp;token) const;</div><div class="line">    int repeat() const;</div><div class="line">protected:</div><div class="line">    void init();</div><div class="line">    void execute();</div><div class="line">    void onExit();</div><div class="line">private:</div><div class="line">    CuGetTDbPropActivity *d;</div><div class="line">};</div><div class="line"></div><div class="line">#endif // GETTDBPROPACTIVITY_H</div></div><!-- fragment --><p>Right clicking on every method definition in the .h file, you can add an empty implementation in the corresponding cpp.</p>
<p>At this point, we have the structure of an object that clients will use to fetch <a class="el" href="namespaceTango.html">Tango</a> database properties (proxy) and the activity that will carry out the actual task in a separate thread. Let the <a class="el" href="classCuGetTDbPropActivity.html" title="an activity to get properties from the Tango database">CuGetTDbPropActivity</a> constructor accept the list of properties to fetch.</p>
<div class="fragment"><div class="line">#include &quot;cugettdbpropactivity.h&quot;</div><div class="line"></div><div class="line">class CuGetTDbPropActivityPrivate</div><div class="line">{</div><div class="line">public:</div><div class="line">    std::list&lt;CuData&gt; in_data;</div><div class="line">};</div><div class="line"></div><div class="line">CuGetTDbPropActivity::CuGetTDbPropActivity(const std::list&lt;CuData&gt; &amp;in_data)</div><div class="line">{</div><div class="line">    d = new CuGetTDbPropActivityPrivate;</div><div class="line">    d-&gt;in_data = in_data;</div><div class="line">}</div><div class="line"></div><div class="line">CuGetTDbPropActivity::~CuGetTDbPropActivity()</div><div class="line">{</div><div class="line">    delete d;</div><div class="line">}</div></div><!-- fragment --><p><em>cumbia-tango</em> library keeps the <em><a class="el" href="namespaceTango.html">Tango</a></em> aware code in a header/cpp couple of files named <em>tango-world.h/.cpp</em>. There goes the code accessing <a class="el" href="namespaceTango.html">Tango</a> functions, in order to keep them off other places within <em>cumbia</em> code. In your case, you can integrate <a class="el" href="namespaceTango.html">Tango</a> calls in your <em>activity</em> implementation.</p>
<h3>Defining the desired property list.</h3>
<p>A list of <em>CuData</em> will contains the names and the types of properties we want to fetch.</p>
<p><em>Every CuData must contain</em>: </p><ul>
<li>the key "*type*" with one of the values <em>device</em>, <em>device_attribute</em> [=*attribute*], <em>class_attribute</em>, <em>class</em>; </li>
<li>the key "*name*" with the name of the property.</li>
</ul>
<p>The list of <em>CuData</em> will be passed to the <a class="el" href="classCuTDbPropertyReader.html#a5125316ea1178c965bdebc971d598abd" title="Get a list of device, class or attribute properties from the Tango database.">CuTDbPropertyReader::get</a> method.</p>
<h3>Registering <em><a class="el" href="classCuGetTDbPropActivity.html" title="an activity to get properties from the Tango database">CuGetTDbPropActivity</a></em> with Cumbia</h3>
<p>Every activity must be registered with cumbia, so that it can be searched by token, paused and resumed (if it's a <em>continuous</em> activity), and finally unregistered. Cumbia searches amongst all the registered threads to see if one with the same <em>token</em> is already there. If not, a new one is created and started. For example, in <a class="el" href="classCuTReader.html" title="Low level class to read tango attributes and commands with output arguments.">CuTReader</a> a thread token is created with the "device" key associated to the <a class="el" href="namespaceTango.html">Tango</a> device name. In this way, Cumbia reuses threads working on the same device. To do so, a Cumbia method is available:</p>
<div class="fragment"><div class="line">void registerActivity(CuActivity *activity, </div><div class="line">   CuThreadListener *dataListener, </div><div class="line">   const CuData&amp; thread_token, </div><div class="line">   const CuThreadFactoryImplI&amp; thread_factory_impl, </div><div class="line">   const CuThreadsEventBridgeFactory_I&amp; eventsBridgeFactoryImpl);</div></div><!-- fragment --><ul>
<li>activity is the CuActivity implementation (<a class="el" href="classCuGetTDbPropActivity.html" title="an activity to get properties from the Tango database">CuGetTDbPropActivity</a>); </li>
<li>dataListener is the <em>activity data listener</em>; </li>
<li>thread_factory_impl is a factory that provides a thread implementation. We will use CuThread, cumbia C++ 11 thread. </li>
<li>eventsBridgeFactoryImpl a bridge that is used to post events from the <em>activity thread</em> to the <em>main thread</em>. Within a Qt application, Qt event loop can be used, in conjunction with QApplication::postEvent.</li>
</ul>
<p><a class="el" href="classCumbiaTango.html">CumbiaTango</a> provides methods to get the thread factory and the event bridge in use.</p>
<p>Let's then mix these ingredients to register our activity in the <a class="el" href="classCuTDbPropertyReader.html#a5125316ea1178c965bdebc971d598abd" title="Get a list of device, class or attribute properties from the Tango database.">CuTDbPropertyReader::get</a> method:</p>
<ul>
<li>two more include files must be added: <div class="fragment"><div class="line">#include &lt;cuthreadfactoryimpl_i.h&gt;</div><div class="line">#include &lt;cuthreadseventbridgefactory_i.h&gt;</div><div class="line"></div><div class="line">#include &quot;gettdbpropactivity.h&quot; // our activity</div></div><!-- fragment --></li>
</ul>
<ul>
<li>Activity is instantiated and registered. The registerActivity method requires a <em>thread token</em>. The thread token makes a thread shareable between activities. There is no particular reason to share a thread across multiple <a class="el" href="classCuGetTDbPropActivity.html" title="an activity to get properties from the Tango database">CuGetTDbPropActivity</a> instances. So we ask clients to provide a unique <em>id</em> in the <a class="el" href="classCuTDbPropertyReader.html" title="Read Tango device, attribute and class properties.">CuTDbPropertyReader</a> constructor, as aforementioned. It was stored in the id string field of CuTDbPropertyReaderPrivate.</li>
</ul>
<div class="fragment"><div class="line">void CuTDbPropertyReader::get(const std::list&lt;CuData&gt; &amp;in_data)</div><div class="line">{</div><div class="line">    CuData thread_tok(&quot;id&quot;, d-&gt;id);  // build the thread token using the id</div><div class="line">    d-&gt;activity = new CuGetTDbPropActivity();  // instantiate activity</div><div class="line">    // get application wide thread events bridge factory (typically, Qt event loop/postEvent in Qt QApplication)</div><div class="line">    const CuThreadsEventBridgeFactory_I &amp;bf = *(d-&gt;cumbia_t-&gt;getThreadEventsBridgeFactory());</div><div class="line">    // get application wide thread factory implementation (typically, CuThread&#39;s)</div><div class="line">    const CuThreadFactoryImplI &amp;fi = *(d-&gt;cumbia_t-&gt;getThreadFactoryImpl());</div><div class="line">    d-&gt;cumbia_t-&gt;registerActivity(d-&gt;activity, this, thread_tok, fi, bf);</div><div class="line">}</div></div><!-- fragment --><p>Cumbia <em>registerActivity</em> creates a new thread and starts it. At this point, we must write the code to fetch the properties from the database inside the activity three entry points: init, execute and onExit.</p>
<h3>Doing the work inside the activity</h3>
<p>Database properties are fetched in a separate thread. Let's have a look at the <a class="el" href="classCuGetTDbPropActivity.html" title="an activity to get properties from the Tango database">CuGetTDbPropActivity</a> three <em>worker</em> methods. The list of properties to get is stored in the in_data field of the CuGetTDbPropActivityPrivate object. We make use of the method <a class="el" href="classCuTangoWorld.html#acfc9bb8654632b53b49be27fcb0fd0bd" title="CuTangoWorld::get_properties.">CuTangoWorld::get_properties</a>, written in the library file <a class="el" href="cutango-world_8cpp.html">cutango-world.cpp</a>. It accepts as input a list of CuData and a reference to a CuData where results are placed. A tango database host can be optionally specified as last parameter.</p>
<p>get_properties method definition, from <a class="el" href="cutango-world_8cpp.html">cutango-world.cpp</a></p>
<div class="fragment"><div class="line">bool CuTangoWorld::get_properties(const std::list&lt;CuData&gt; &amp;in_list, CuData &amp;res, const std::string&amp; dbhost)</div></div><!-- fragment --><p>All the work is carried out by this method, so let's call it from within the <em>execute</em> method of <a class="el" href="classCuGetTDbPropActivity.html" title="an activity to get properties from the Tango database">CuGetTDbPropActivity</a>, in the <a class="el" href="cugettdbpropactivity_8cpp.html">cugettdbpropactivity.cpp</a> file:</p>
<div class="fragment"><div class="line">#include &lt;cutango-world.h&gt;</div><div class="line">#include &lt;cumacros.h&gt; // printf, perr...</div></div><!-- fragment --><p>Using the <a class="el" href="classCuTangoWorld.html">CuTangoWorld</a> class helper we fetch the properties, that are saved within res, of type CuData. Finally, to make the result available on the main thread, we must remember to call publishResult.</p>
<div class="fragment"><div class="line">void CuGetTDbPropActivity::execute()</div><div class="line">{</div><div class="line">    CuTangoWorld tw;</div><div class="line">    CuData res;</div><div class="line">    tw.get_properties(d-&gt;in_data, res);</div><div class="line">    publishResult(res);</div><div class="line">}</div></div><!-- fragment --><h3>Testing the code</h3>
<p>We have now to test the written code. To accomplish this, with qt creator we create a plain C++ application. The project name can be "dbproperties". We will write a command line utility to print the device/class/attribute properties on the command line. Open the dbproperties.pro file: we need to add the include path and libraries for cumbia and cumbia tango</p>
<div class="fragment"><div class="line">#</div><div class="line"># dbproperties.pro</div><div class="line">INCLUDEPATH += /usr/local/include/cumbia /usr/local/include/cumbia-tango</div><div class="line">LIBS += -L/usr/local/lib -lcumbia-tango</div></div><!-- fragment --><p>Create the project and then add a new class named "PropertyReader".</p>
<p>Let PropertyReader inherit from CuDataListener and add the pure virtual method onUpdate implementation with qt creator. Its constructor can have empty arguments, while a <em>get</em> method will accept an <em>id</em> as string and the list of required properties and use a <a class="el" href="classCuTDbPropertyReader.html" title="Read Tango device, attribute and class properties.">CuTDbPropertyReader</a> to fetch them. <em>onUpdate</em> will receive the results.</p>
<p>Let's start having a look at the skeleton of the PropertyReader class created with qt creator.</p>
<h4>File propertyreader.h</h4>
<div class="fragment"><div class="line">#include &lt;cudatalistener.h&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line"></div><div class="line">class PropertyReader : public CuDataListener</div><div class="line">{</div><div class="line">public:</div><div class="line">    PropertyReader(const std::vector&lt;std::string&gt; props);</div><div class="line"></div><div class="line">    // CuDataListener interface</div><div class="line">public:</div><div class="line">    void onUpdate(const CuData &amp;data);</div><div class="line">};</div></div><!-- fragment --><h4>File propertyreader.cpp</h4>
<p>Add the necessary includes to the .cpp file</p>
<div class="fragment"><div class="line">#include &quot;propertyreader.h&quot;</div><div class="line">#include &lt;cutdbpropertyreader.h&gt;</div><div class="line">#include &lt;cumacros.h&gt;</div><div class="line">#include &lt;cudata.h&gt;</div><div class="line">#include &lt;algorithm&gt; // for find in vector</div><div class="line">#include &lt;list&gt;</div><div class="line">#include &lt;cuthreadfactoryimpl.h&gt;</div><div class="line">#include &lt;cuthreadseventbridge.h&gt;</div><div class="line">#include &lt;cumbiatango.h&gt;</div></div><!-- fragment --><p>As required by cumbia applications, a <a class="el" href="classCumbiaTango.html">CumbiaTango</a> object must be instantiated for <a class="el" href="namespaceTango.html">Tango</a> clients. Since cumbia is <em>multi threaded</em>, we must pass a C++ thread implementation to the <a class="el" href="classCumbiaTango.html">CumbiaTango</a> constructor, as well as a so called <em>bridge</em> that is used to forward events from the secondary thread (<em>worker</em>) to the main one. Cumbia offers base implementations of both objects. For Qt applications, we would use <em>QThreadsEventBridge</em>, that employs Qt QApplication and QApplication's <em>postEvent</em> as a means to deliver events between separate threads. For non Qt applications, we will use base event loop and event bridge provided by cumbia, namely CuThreadsEventBridge. For both Qt and non Qt applications, CuThread (cumbia C++11 thread implementation) are normally used. These two objects that parametrize <a class="el" href="classCumbiaTango.html">CumbiaTango</a> are not directly instantiated by the client, but rather through a couple of factories. In the Qt/QApplication scenario, QApplication transparently runs an event loop. In our simple console application, we must start the cumbia base event loop. This is accomplished in the PropertyReader constructor as follows:</p>
<div class="fragment"><div class="line">PropertyReader::PropertyReader()</div><div class="line">{</div><div class="line">    m_ct = new CumbiaTango(new CuThreadFactoryImpl(), new CuThreadsEventBridgeFactory());</div><div class="line">    m_ct-&gt;getServiceProvider()-&gt;registerService(CuServices::EventLoop, new CuEventLoopService());</div><div class="line">    /* start the event loop in a separate thread (true param), where data from activities will be posted */</div><div class="line">    static_cast&lt;CuEventLoopService*&gt;(m_ct-&gt;getServiceProvider()-&gt;get(CuServices::EventLoop))-&gt;exec(true);</div><div class="line">}</div></div><!-- fragment --><p>The event loop is a cumbia <em>service</em>. Cumbia avoids <em>singleton</em> patterns and it rather uses the service provider pattern to supply application wide access to "services" from anywhere. CuServiceProvider is where services are registered and then fetched (see the <em>registerService</em> and <em>get</em> methods in the snipped above. The event loop is <em>exec</em>uted at last.</p>
<p><em>m_ct</em> is a <a class="el" href="classCumbiaTango.html">CumbiaTango</a> class attribute, that is declared within PropertyReader class definition.</p>
<h4>File main.cpp</h4>
<p>Let's now examine the main.cpp of this application before going back to the propertyreader.cpp. Properties are saved into a vector of strings by parsing the command line arguments. Then a PropertyReader is asked to fetch them from the <a class="el" href="namespaceTango.html">Tango</a> database.</p>
<div class="fragment"><div class="line">#include &quot;propertyreader.h&quot;</div><div class="line"></div><div class="line">int main(int argc, char *argv[])</div><div class="line">{</div><div class="line">    std::vector&lt;std::string&gt; props;</div><div class="line">    for(int i = 1; i &lt; argc; i++)</div><div class="line">        props.push_back( std::string(argv[i]));</div><div class="line">    PropertyReader pr;</div><div class="line">    pr.get(&quot;pr1&quot;, props);</div><div class="line">}</div></div><!-- fragment --><h4>File propertyreader.cpp (2)</h4>
<p>The <em>get</em> method of the PropertyReader class will be now discussed. The first argument is an <em>id</em> that helps cumbia execute several property readers in different threads. The second is a list of strings with the desired properties. Basically, in the <em>for</em> loop, the program tries to distinguish between device, attribute and class property according to the expression provided in the command line. The application recognizes these three forms:</p>
<ul>
<li>test/device/1:description to fetch the device property <em>description</em> from the device test/device/1 </li>
<li>test/device/1/double_scalar:values to fetch the <em>values</em> attribute property from device test/device/1 and attribute double_scalar </li>
<li>TangoTest:Description to fetch the <em>Description</em> property from the TangoTest class.</li>
</ul>
<p><em>get</em> parses the queries and adds a descriptive CuData to a list called <em>in_list</em>.</p>
<p>When the list is ready, a <a class="el" href="classCuTDbPropertyReader.html" title="Read Tango device, attribute and class properties.">CuTDbPropertyReader</a> is created, addListener is called to get updates and finally <a class="el" href="classCuTDbPropertyReader.html#a5125316ea1178c965bdebc971d598abd" title="Get a list of device, class or attribute properties from the Tango database.">CuTDbPropertyReader::get</a> is called with the string <em>id</em> and the list as parameters.</p>
<p>Since <a class="el" href="classCuTDbPropertyReader.html" title="Read Tango device, attribute and class properties.">CuTDbPropertyReader</a> works in a separate thread, we must keep the current one waiting for the results. For this, right after the <a class="el" href="classCuTDbPropertyReader.html#a5125316ea1178c965bdebc971d598abd" title="Get a list of device, class or attribute properties from the Tango database.">CuTDbPropertyReader::get</a> call, we ask the event loop to wait for the <em>exit signal</em>. The <em>exit signal</em> is invoked by the PropertyReader::onUpdate method, once data has been received and displayed.</p>
<div class="fragment"><div class="line">// test/device/1:description device property: two &#39;/&#39; and &#39;:&#39;</div><div class="line">// test/device/1/double_scalar:values attribute properties: three &#39;/&#39; and one &#39;:&#39;</div><div class="line">// TangoTest:Description class property: one &#39;/&#39;</div><div class="line">void PropertyReader::get(const char *id, const std::vector&lt;std::string&gt; &amp;props)</div><div class="line">{</div><div class="line">    /* start the event loop in a separate thread, where data from activities will be posted */</div><div class="line">    std::list&lt;CuData&gt; in_data;</div><div class="line">    for(size_t i = 0; i &lt; props.size(); i++) {</div><div class="line">        size_t cnt = count(props[i].begin(), props[i].end(), &#39;/&#39;);</div><div class="line">        size_t cpos = props[i].find(&#39;:&#39;);</div><div class="line">        if(cnt == 2 &amp;&amp; cpos &lt; std::string::npos)</div><div class="line">        {</div><div class="line">            CuData devpd(&quot;device&quot;, props[i].substr(0, cpos));</div><div class="line">            devpd[&quot;name&quot;] = props[i].substr(cpos + 1, std::string::npos);</div><div class="line">            in_data.push_back(devpd);</div><div class="line">        }</div><div class="line">        else if(cnt == 3) {</div><div class="line">            CuData devpd(&quot;device&quot;, props[i].substr(0, props[i].rfind(&#39;/&#39;)));</div><div class="line">            if(cpos &lt; std::string::npos) {</div><div class="line">                devpd[&quot;attribute&quot;] = props[i].substr(props[i].rfind(&#39;/&#39;) + 1, cpos - props[i].rfind(&#39;/&#39;) -1);</div><div class="line">                devpd[&quot;name&quot;] = props[i].substr(cpos + 1, std::string::npos);</div><div class="line">            }</div><div class="line">            else</div><div class="line">                devpd[&quot;attribute&quot;] = props[i].substr(props[i].rfind(&#39;/&#39;) + 1, cpos); // cpos == npos</div><div class="line"></div><div class="line">            in_data.push_back(devpd);</div><div class="line">        }</div><div class="line">        else if(cnt == 0 &amp;&amp; cpos &lt; std::string::npos) { // class</div><div class="line">            CuData cld(&quot;class&quot;, props[i].substr(0, cpos));</div><div class="line">            cld[&quot;name&quot;] = props[i].substr(cpos + 1);</div><div class="line">            in_data.push_back(cld);</div><div class="line">        }</div><div class="line">    }</div><div class="line">    CuTDbPropertyReader *pr = new CuTDbPropertyReader(id, m_ct);</div><div class="line">    pr-&gt;addListener(this);</div><div class="line">    pr-&gt;get(in_data);</div><div class="line">    static_cast&lt;CuEventLoopService*&gt;(m_ct-&gt;getServiceProvider()-&gt;get(CuServices::EventLoop))-&gt;wait();</div><div class="line">    delete m_ct;</div><div class="line">    delete pr;</div><div class="line">}</div></div><!-- fragment --><p>As you can see, after *wait*ing, we proceed to delete the <a class="el" href="classCumbiaTango.html">CumbiaTango</a> and the <a class="el" href="classCuTDbPropertyReader.html" title="Read Tango device, attribute and class properties.">CuTDbPropertyReader</a>.</p>
<p>The <em>onUpdate</em> method below simply extracts data from the CuData received and prints it nicely on the console. Finally, <em>exit</em> is called on the event loop.</p>
<div class="fragment"><div class="line">void PropertyReader::onUpdate(const CuData &amp;data)</div><div class="line">{</div><div class="line">    if(data[&quot;err&quot;].toBool())</div><div class="line">        printf(&quot;\n\e[1;31m** \e[0m error fetching properties: \e[1;31m%s\e[0m\n&quot;, data[&quot;msg&quot;].toString().c_str());</div><div class="line">    else</div><div class="line">        printf(&quot;\n\e[1;32m** %45s     VALUES\e[0m\n&quot;, &quot;PROPERTIES&quot;);</div><div class="line">    std::vector&lt;std::string&gt; plist = data[&quot;list&quot;].toStringVector();</div><div class="line">    for(size_t i = 0; i &lt; plist.size(); i++)</div><div class="line">        printf(&quot;\e[1;32m--\e[0m %55s \e[1;33m--&gt; \e[0m%s\n&quot;, plist[i].c_str(), data[plist[i]].toString().c_str());</div><div class="line">    static_cast&lt;CuEventLoopService*&gt;(m_ct-&gt;getServiceProvider()-&gt;get(CuServices::EventLoop))-&gt;exit();</div><div class="line">}</div></div><!-- fragment --><p>The data handed to the <em>onUpdate</em> method contains a "list" key which value is a list of strings containing all the names of the properties stored in the CuData. Iterating on such list we are able to print the value of each property as a string.</p>
<h3>Application output example</h3>
<p>When the <em>dbproperties</em> application is launched with this command:</p>
<div class="fragment"><div class="line">./dbproperties test/device/1:description test/device/1/double_scalar:unit test/device/1/double_scalar:max_alarm TangoTest:Csoglia TangoTest:doc_url test/device/1:helperApplication test/device/1:values test/device/2/double_scalar:values</div></div><!-- fragment --><p>the output is like this:</p>
<div class="fragment"><div class="line">**                                    PROPERTIES     VALUES</div><div class="line">--                        test/device/1/double_scalar:unit --&gt; Pippeross</div><div class="line">--                               test/device/1:description --&gt; This is a Tango Test device with ,many interesing attributes and commands</div><div class="line">--                         test/device/1:helperApplication --&gt; atkpanel</div><div class="line">--                                    test/device/1:values --&gt; 10,20,30,40,50</div><div class="line">--                                       TangoTest:Csoglia --&gt; 5</div><div class="line">--                                       TangoTest:doc_url --&gt; http://www.esrf.eu/computing/cs/tango/tango_doc/ds_doc/</div></div><!-- fragment --><p>As you can see, there is no <em>test/device/2/double_scalar:values</em> property in the tango database at the moment.</p>
<p>If you want to know all the properties of an attribute <em>and</em> the <em>tango class</em> "Description", you will execute:</p>
<div class="fragment"><div class="line">./dbproperties test/device/1/long_scalar TangoTest:Description</div></div><!-- fragment --><p>and get this result:</p>
<div class="fragment"><div class="line">**                                    PROPERTIES     VALUES</div><div class="line">--                    test/device/1/long_scalar:abs_change --&gt; 4</div><div class="line">--            test/device/1/long_scalar:archive_abs_change --&gt; 1</div><div class="line">--                test/device/1/long_scalar:archive_period --&gt; 2000</div><div class="line">--            test/device/1/long_scalar:archive_rel_change --&gt; 1</div><div class="line">--                   test/device/1/long_scalar:displayMask --&gt; 0,3,5,1</div><div class="line">--                  test/device/1/long_scalar:display_unit --&gt; tapiocas</div><div class="line">--                  test/device/1/long_scalar:falseStrings --&gt; f0,f3,f5,f1</div><div class="line">--                     test/device/1/long_scalar:max_alarm --&gt; 100</div><div class="line">--                     test/device/1/long_scalar:max_value --&gt; 280</div><div class="line">--                   test/device/1/long_scalar:max_warning --&gt; 100</div><div class="line">--                     test/device/1/long_scalar:min_alarm --&gt; 1</div><div class="line">--                     test/device/1/long_scalar:min_value --&gt; 0</div><div class="line">--                   test/device/1/long_scalar:min_warning --&gt; 1</div><div class="line">--                    test/device/1/long_scalar:numColumns --&gt; 4</div><div class="line">--                       test/device/1/long_scalar:numRows --&gt; 1</div><div class="line">--                    test/device/1/long_scalar:rel_change --&gt; 3</div><div class="line">--                 test/device/1/long_scalar:standard_unit --&gt; tapiocasStdUnit</div><div class="line">--                   test/device/1/long_scalar:trueStrings --&gt; v0,v3,v5,v1</div><div class="line">--                          test/device/1/long_scalar:unit --&gt; tapiocasUnit</div><div class="line">--                        test/device/1/long_scalar:values --&gt; Pippo,Pluto,Minnie,Briscola,Re,Torre,Asso,Gemello,Ariete,Toro,Ponyo</div><div class="line">--                                   TangoTest:Description --&gt; A device to test generic clients. It offers a &quot;echo&quot; like command for,each TANGO data type (i.e. each command returns an exact copy of &lt;argin&gt;).</div></div><!-- fragment --><h3>Final observations</h3>
<p>In this tutorial we've learnt how to deal with writing a simple cumbia <em>activity</em>. The client of the activity, the <em>property reader</em> example, is a little bit complicated by the need of dealing with activities that work in a separate thread. For this, we had to use cumbia <em>event loop</em> implementation, calling <em>execute</em>, <em>wait</em> and <em>exit</em> at the right moment. Generally, activities are thought to be used within a multi threaded environment where a event loop is given <em>for free</em>, as it is in Qt's <em>QApplication</em>. In that case, the programmer's work is much easier. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Sep 13 2019 15:09:51 for cumbia-tango by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
