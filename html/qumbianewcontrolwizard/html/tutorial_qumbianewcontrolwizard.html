<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cumbia new control: Quickly add a Qt widget to your cumbia project</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cumbia new control
   &#160;<span id="projectnumber">1.x</span>
   </div>
   <div id="projectbrief">Create a new control element that integrates with cumbia-qtcontrols</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Quickly add a Qt widget to your cumbia project </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this exercise we will learn how to add to a cumbia project a custom widget to display or write data.</p>
<h4>Requirements</h4>
<p>The following components must be installed:</p>
<ul>
<li>cumbia </li>
<li>cumbia-tango </li>
<li>cumbia-qtcontrols </li>
<li>qumbia-tango-controls </li>
<li>qumbia-plugins/qt-designer </li>
<li>qumbia-apps/cuuimake, the tool to process ui, pro, h and cpp files and </li>
<li>qumbia-apps/qumbiaprojectwizard, the tool to create a new cumbia project</li>
</ul>
<h4>Install qumbiaprojectwizard</h4>
<p>Change directory into <em>qumbia-apps/qumbianewcontrolwizard</em> and execute</p>
<div class="fragment"><div class="line">qmake</div><div class="line">make -j5</div><div class="line">sudo make install</div></div><!-- fragment --><p>To build all the <em>qumbia-apps</em> utilities, the same code can be run from the <em>qumbia-apps</em> parent directory.</p>
<h4>Command line</h4>
<div class="fragment"><div class="line">cumbia new project</div></div><!-- fragment --><h2>Use <em>cumbia new project</em> to create a new cumbia project</h2>
<p>Create a new project referring to tutorial_qumbiatango</p>
<p>In this example, we create our project under the devel/exercises directory in the home user. The project name is CumbiaCustomControls.</p>
<p>The <em>qumbiaprojectwizard</em> utility can be launched with</p>
<div class="fragment"><div class="line">cumbia new project</div></div><!-- fragment --><p>A picture of the qumbiaprojectwizard application follows.</p>
<div class="image">
<img src="qumbiaprojectwizard_customcontrols.png" alt="qumbiaprojectwizard_customcontrols.png"/>
<div class="caption">
qumbiaprojectwizard application</div></div>
<p> Choose <em>tango</em> in the <em>Support</em> box, select the location and click on create. We could select <em>epics</em> or <em>tango-epics</em> as well and nothing would change in the following procedure.</p>
<p>Once the <em>Create</em> button has been clicked, the project skeleton has been generated in the chosen directory and Qt designer and Qt creator have been started automatically.</p>
<p>Edit the form in the <em>Qt designer</em> and add</p>
<ul>
<li>a QLabel with the name of the tango <em>double_scalar</em> attribute (base <em>Qt widget</em>);</li>
<li>a QuLabel with the "$1/double_scalar" source, as shown in the picture below (a <em>cumbia-qtcontrols</em> base widget);</li>
<li>a QuApplyNumeric with the "$1/double_scalar" target (another <em>cumbia-qtcontrols</em> base widget)</li>
</ul>
<p>The form will include two additional control elements that are not part of the <em>cumbia-qtcontrols</em> distribution. They are simple <em>Qt widgets</em> <b>that will later be promoted</b> to <b>custom</b> <em>cumbia</em> widgets. One will become a <em>cumbia reader</em>, the other a <em>writer</em>. Let's add these two elements:</p>
<ul>
<li>a QTreeWidget with two columns: it will show the <em>history</em> of the <em>double_scalar</em> attribute (with a configurable number of rows)</li>
<li>a QDial to change the value of the <em>double_scalar</em></li>
<li>a QSpinBox to set the maximum depth of the history in the QTreeWidget</li>
</ul>
<p>Finally, place a couple of labels to describe the additional elements.</p>
<p>The <em>double_scalar</em> is a Tango attribute available from the <em>TangoTest</em> device distributed with the <em>Tango</em> software package. The <em>$1</em> is a <em>wildcard</em> that is substituted at runtime with the first <em>command line argument</em> that represents a <em>Tango</em> device name. The application will be started with this command:</p>
<div class="fragment"><div class="line">./bin/CumbiaCustomWidgets  test/device/1</div></div><!-- fragment --><p>supposing that the <em>TangoTest</em> device defined in the <em>Tango database</em> is named <em>test/device/1</em> (it could be <em>sys/tg_test/1</em> or something else, depending on how you installed the Tango software).</p>
<p>Since the <em>cumbia new control</em> utility will create objects fitted with the <em>source</em> property to set up the connection end point for the reader and the <em>target</em> property for the writer, select the QTreeWidget on the <em>Qt designer</em> form, go to the <em>property editor</em>, click on the <em>plus</em> (<b>+</b>) icon and choose <em>string</em>.</p>
<p>Below is a screenshot of the Qt designer with the elements listed above:</p>
<div class="image">
<img src="cumbiacustomw_designer.png" alt="cumbiacustomw_designer.png"/>
<div class="caption">
Qt designer form editor</div></div>
<p> Once you click <em>Ok</em>, the <em>Property Editor</em> scrolls down to the bottom, focusing on the new <em>source</em> property in the <em>Dynamic Properties</em> view. Type <em>$1/double_scalar</em> in the <em>source</em> field.</p>
<p>Do the very same with the QDial, using <em>target</em> as <em>property name</em> and <em>$1/double_scalar</em> as property value.</p>
<p>Save the form and proceed to the next paragraph to create the custom widgets to integrate in the cumbia project.</p>
<h2>Use <em>cumbia new control</em> to write the custom reader and writer</h2>
<p>Open a terminal and move to the new project directory:</p>
<div class="fragment"><div class="line">cd ~/devel/exercises/CumbiaCustomWidgets</div></div><!-- fragment --><p>Start the <em>cumbia new control</em> application:</p>
<div class="fragment"><div class="line">cumbia new control</div></div><!-- fragment --><p>The application should have detected the <em>qt project file</em> "*CumbiaCustomWidgets.pro*" because it has been launched from within a folder where a <em>Qt project</em> resides. At the bottom, you should see the correct path <em>plus the src directory</em>, because the project carpet contains a <em>src</em> sub directory. If everything is as expected proceed to generate the skeleton code for the custom reader and writer.</p>
<h3>Generate the custom <em>reader</em></h3>
<p>In the <em>New cumbia control object</em> window:</p>
<ul>
<li>type the name of the control in the <em>Name</em> text box at the top: MyAttributeHistoryTree;</li>
<li>from the <em>inherits from</em> drop down menu, choose QTreeWidget. The <em>include</em> field should be updated accordingly;</li>
<li>check that the <em>reader</em> radio button is selected</li>
</ul>
<p>If you leave the <em>Add to project under</em> check box is active, the application will add the myattributehistorytree.h and myattributehistorytree.cpp files to the project. You can optionally modify the <em>brief class description</em> and the <em>Class description</em> fields that will make up the class documentation.</p>
<div class="image">
<img src="qumbianewcontrolw.png" alt="qumbianewcontrolw.png"/>
<div class="caption">
cumbia new control application wizard is ready to generate a custom reader</div></div>
<p> Click on the <em>Generate</em> button. If you switch to the <em>Qt creator</em> window, you should see the two new files in the project file list. If you open them, you'll recognize the structure of a working reader!</p>
<h3>Generate the custom <em>writer</em></h3>
<p>Go back to the <em>New cumbia control object</em> window.</p>
<ul>
<li>change the <em>Name</em> of the new class to <em>MyDial</em></li>
<li>click on the <em>writer</em> button in the <em>Type</em> box</li>
<li>select QDial as parent widget from the <em>inherits from</em> drop down list</li>
</ul>
<p>You should see that some fields have been updated accordingly for you: the <em>header</em> and <em>cpp</em> file names and the descriptions.</p>
<p>Click on <em>Generate</em> once again and verify that MyDial has been added to the <em>Qt creator</em> project.</p>
<div class="image">
<img src="qumbianewcontrolw2.png" alt="qumbianewcontrolw2.png"/>
<div class="caption">
cumbia new control application wizard is ready to generate a custom writer</div></div>
 <h3>Try to build the project</h3>
<p>Go to the <em>terminal window</em> previously opened in the *~/devel/exercises/CumbiaCustomWidgets* directory and try to build the project</p>
<div class="fragment"><div class="line">cumbia ui make --qmake</div></div><!-- fragment --><p>The output should look like this:</p>
<div class="image">
<img src="cuuimake1.png" alt="cuuimake1.png"/>
<div class="caption">
"cumbia ui make" output</div></div>
<p> If you run</p>
<div class="fragment"><div class="line">make -j3</div></div><!-- fragment --><p>the project should compile smoothly.</p>
<p>Yet, this is not the end of the story, because the <em>user interface form</em> previously laid out with the designer still employs the base Qt <em>QTreeWidget</em> and <em>QDial</em> classes. Go to the designer, select the <em>QTreeWidget</em>, right click on it and choose <em>Promote to...</em>; In the <em>Promoted class name</em> field type <em>MyAttributeHistoryTree</em>, click on <em>Add</em>, then <em>Promote</em>:</p>
<div class="image">
<img src="promote1.png" alt="promote1.png"/>
<div class="caption">
promote QTreeWidget to the custom MyAttributeHistoryTree</div></div>
<p> As you can see from the picture above, the name of the <em>header file</em> should match the file in the project.</p>
<p>Do the same with <em>QDial</em> and promote it to <em>MyDial</em>.</p>
<p>Save the form.</p>
<p>Go back to the console and type</p>
<div class="fragment"><div class="line">cumbia ui make</div><div class="line">make -j3</div></div><!-- fragment --><p>The project builds and if we start the application</p>
<div class="fragment"><div class="line">./bin/CumbiaCustomWidgets test/device/1</div></div><!-- fragment --><p>we can see that the QuLabel and QuApplyNumeric are working.</p>
<p><em>cumbia new control</em> has created the skeleton of the custom reader (<em>MyAttributeHistoryTree</em>) and writer (<em>MyDial</em>). To activate them, a couple of things still have to be done:</p>
<ul>
<li>QDial <em>valueChanged(int)</em> signal must be connected to the <em>write(int)</em> slot. The <em>slot</em> is already declared and implemented in the generated files, the <em>signal/slot</em> connection is also there but has to be uncommented in MyDial constructor:</li>
<li>the <em>MyAttributeHistoryTree</em> specific code must be written in the <em>onUpdate</em> method so that every time a new value is available, it is recorded in the history. When the number of items in the history reaches the <em>history depth</em> value (displayed in the <em>depth</em> spinbox), the oldest records must be removed.</li>
</ul>
<h4>Activate the dial signal/slot connection</h4>
<p>Open <em>mydial.cpp</em> and look for the <em>m_create_connections</em> method. You will find a commented section with several <em>signal/slot</em> connections prepared for you. Uncomment the first one to activate the writings when the dial is rotated:</p>
<div class="fragment"><div class="line">void MyDial::m_create_connections() {</div><div class="line">    // enable one of these connections or write a custom one to trigger a write operation</div><div class="line">    //</div><div class="line">    // ---------------------------------------------------------------------------------------------------</div><div class="line">    //</div><div class="line">    connect(this, SIGNAL(valueChanged(int)), this, SLOT(write(int)));</div><div class="line">//    connect(this, SIGNAL(valueChanged(double)), this, SLOT(write(double)));</div><div class="line">//    ...</div><div class="line">}</div></div><!-- fragment --><p>If you rebuild and execute the application, the dial is now able to write!</p>
<h4>Implement the history view</h4>
<p>Open the <em>myattributehistorytree.cpp</em> file and locate the <em>onUpdate</em> method. This is the callback where cumbia delivers new data fetched from the source. If the number of displayed items is greater then or equal to the history depth, we will remove the excess ones. The current depth can be stored as an integer class attribute defined in the MyAttributeHistoryTreePrivate class defined in the very same *.cpp* file:</p>
<div class="fragment"><div class="line">class MyAttributeHistoryTreePrivate</div><div class="line">{</div><div class="line">public:</div><div class="line">    bool auto_configure;</div><div class="line">    bool read_ok;</div><div class="line">    CuContext *context;</div><div class="line"></div><div class="line">    int depth; // &lt;-- the depth attribute</div><div class="line">};</div></div><!-- fragment --><p>A <em>slot</em> in MyAttributeHistoryTree class and a <em>signal/slot connection</em> in <em>CumbiaCustomWidgets.cpp</em> must be added so that when the <em>depth</em> spinbox value changes, the <em>depth</em> in the <em>MyAttributeHistoryTree</em> is updated:</p>
<p>In <em>myattributehistorytree.h</em>:</p>
<div class="fragment"><div class="line">// ...</div><div class="line">public slots:</div><div class="line"></div><div class="line">    void setHistoryDepth(int d);</div><div class="line">// ...</div></div><!-- fragment --><p>In <em>CumbiaCustomWidgets.cpp</em> constructor, write the <em>signal/slot</em> connection after using the same <em>setHistoryDepth slot</em> to initialise the <em>depth</em> value:</p>
<div class="fragment"><div class="line">CumbiaCustomWidgets::CumbiaCustomWidgets(CumbiaTango *cut, QWidget *parent) :</div><div class="line">    QWidget(parent)</div><div class="line">{</div><div class="line">    // cumbia-tango</div><div class="line">    cu_t = cut;</div><div class="line">    </div><div class="line">    // ...</div><div class="line">    </div><div class="line">    new CuContextActionBridge(this, cu_t, cu_tango_r_fac);</div><div class="line">    </div><div class="line">    ui-&gt;treeWidget-&gt;setHistoryDepth(ui-&gt;sbDepth-&gt;value());</div><div class="line">    // add this signal slot connection to update the history depth of the tree widget</div><div class="line">    connect(ui-&gt;sbDepth, SIGNAL(valueChanged(int)), ui-&gt;treeWidget, SLOT(setHistoryDepth(int)));  // &lt;----</div><div class="line">}</div></div><!-- fragment --><p>If you use <em>Qt creator</em>, go back to <em>myattributehistorytree.h</em>, right click on the <em>setHistoryDepth slot</em> definition and choose <em>Refactor -&gt; add Definition in myattributehistorytree.cpp</em> to insert the implementation of the slot into the <em>cpp</em> file.</p>
<p>In <em>myattributehistorytree.cpp</em>, you may want find the <em>m_init</em> function and initialize the <em>depth</em> private attribute to <em>10</em>:</p>
<div class="fragment"><div class="line">void MyAttributeHistoryTree::m_init()</div><div class="line">{</div><div class="line">    d = new MyAttributeHistoryTreePrivate;</div><div class="line">    d-&gt;context = NULL;</div><div class="line">    d-&gt;auto_configure = true;</div><div class="line">    d-&gt;read_ok = false;</div><div class="line">    </div><div class="line">    d-&gt;depth = 10; // &lt;-- initialise the history depth </div><div class="line">}</div></div><!-- fragment --><p>Then write the implementation of <em>setHistoryDepth</em>:</p>
<div class="fragment"><div class="line">void MyAttributeHistoryTree::setHistoryDepth(int depth) {</div><div class="line">    d-&gt;depth = depth;</div><div class="line">}</div></div><!-- fragment --><p>Everything is now ready for the final step: integrate the <em>onUpdate</em> method to show the attribute history with the desired depth. Locate the <em>onUpdate</em> function. You will see that the message from the engine is extracted first and the quality of the read operation is saved into the <em>read_ok</em> class attribute. The widget is enabled if the reading is successful and the <em>link statistics</em> are updated. Remove the setEnabled line and also the setToolTip because they are not necessary given the nature of this display widget:</p>
<div class="fragment"><div class="line">void MyAttributeHistoryTree::onUpdate(const CuData &amp;da)</div><div class="line">{</div><div class="line">    QString message = QString::fromStdString(da[&quot;msg&quot;].toString());</div><div class="line">    d-&gt;read_ok = !da[&quot;err&quot;].toBool();</div><div class="line">    // setToolTip(message);</div><div class="line">    // setEnabled(d-&gt;read_ok);</div><div class="line"></div><div class="line">    // update link statistics</div><div class="line">    d-&gt;context-&gt;getLinkStats()-&gt;addOperation();</div><div class="line">    if(!d-&gt;read_ok)</div><div class="line">        d-&gt;context-&gt;getLinkStats()-&gt;addError(da[&quot;msg&quot;].toString());</div><div class="line"></div><div class="line">    // configure object if the type of received data is &quot;property&quot;</div><div class="line">    if(d-&gt;read_ok &amp;&amp; d-&gt;auto_configure &amp;&amp; da[&quot;type&quot;].toString() == &quot;property&quot;) {</div><div class="line">        m_configure(da);</div><div class="line">    }</div><div class="line">    </div><div class="line">    // ...</div></div><!-- fragment --><p>The remaining code in the same method offers a generic solution to set a value on simple widgets exporting <em>methods or properties</em> like <em>setValue (property: value), setText (text), setCurrentText (currentText)</em>. Our base class is more complex: a <em>QTreeWidget</em> where, in every row, we display four pieces of information:</p>
<ul>
<li>the date and time of the operation</li>
<li>the value read</li>
<li>the set point value (if present)</li>
<li>the outcome of the operation</li>
</ul>
<p>We fetch the necessary information from the following fields from the <em>CuData</em> passed as parameter to the <em>onUpdate</em>, converting it to string since the columns of a <em>tree widget item (QTreeWidgetItem)</em> are strings:</p>
<ul>
<li></li>
<li>data["value"].toString()</li>
<li>data["w_value"].toString() (if data.containsKey("w_value"))</li>
<li>data["timestamp_ms"].toLongInt() as to the <a href="../../cumbia-tango/html/cudata_for_tango.html">CuData bundle description for data exchange with the Tango world</a> documentation, *"CuData bundle description for data exchange with the Tango world"* table.</li>
<li>data["message"].toString()</li>
</ul>
<p>Converting CuData "value" and "w_value" to string is not only proper for displaying in the columns of a <em>QTreeWidgetItem</em>; it is often a good generic approach to display values whose type is not known aprioristically.</p>
<p>After these considerations, complete the project. Remove all the automatically generated code that <em>follows</em>:</p>
<div class="fragment"><div class="line">// configure object if the type of received data is &quot;property&quot;</div><div class="line">if(d-&gt;read_ok &amp;&amp; d-&gt;auto_configure &amp;&amp; da[&quot;type&quot;].toString() == &quot;property&quot;) {</div><div class="line">    m_configure(da);</div><div class="line">}</div></div><!-- fragment --><p>and proceed with the code integration. Truncate to 30 characters the message to be set on the column index 3 of the tree widget and set the entire message as tooltip instead. Set the color of the first and fourth column of the items according to the reading outcome. If you want to reuse MyAttributeHistoryTree class, it can be a good idea to emit the <em>newData</em> signal at the end.</p>
<div class="fragment"><div class="line">void MyAttributeHistoryTree::onUpdate(const CuData &amp;da)</div><div class="line">{</div><div class="line">    // ...</div><div class="line">    if(d-&gt;read_ok &amp;&amp; d-&gt;auto_configure &amp;&amp; da[&quot;type&quot;].toString() == &quot;property&quot;) {</div><div class="line">        m_configure(da);</div><div class="line">    }</div><div class="line">    </div><div class="line">     // 1. remove items if too many</div><div class="line">    while(topLevelItemCount() &gt;= d-&gt;depth)</div><div class="line">        delete takeTopLevelItem(0);</div><div class="line"></div><div class="line">   // 2. add the new item</div><div class="line">    std::string read = &quot;-&quot;, write = &quot;-&quot;;</div><div class="line">    QString timestamp = QDateTime::fromMSecsSinceEpoch(da[&quot;timestamp_ms&quot;].toLongInt()).toString(&quot;hh:mm:ss.sss&quot;);</div><div class="line">    QString tooltip = message;</div><div class="line">    message.truncate(40);</div><div class="line">    if(d-&gt;read_ok &amp;&amp; da.containsKey(&quot;value&quot;))</div><div class="line">        read = da[&quot;value&quot;].toString();</div><div class="line">    if(d-&gt;read_ok &amp;&amp; da.containsKey(&quot;w_value&quot;))</div><div class="line">        write = da[&quot;w_value&quot;].toString();</div><div class="line">    QTreeWidgetItem *it = new QTreeWidgetItem(this, QStringList() &lt;&lt; timestamp &lt;&lt; QString::fromStdString(read)</div><div class="line">                                              &lt;&lt; QString::fromStdString(write) &lt;&lt; message + &quot;...&quot;);</div><div class="line"></div><div class="line">    d-&gt;read_ok ? it-&gt;setForeground(0, QColor(Qt::green)) : it-&gt;setForeground(0, QColor(Qt::red));</div><div class="line">    d-&gt;read_ok ? it-&gt;setForeground(3, QColor(Qt::darkGray)) : it-&gt;setForeground(3, QColor(Qt::red));</div><div class="line">    it-&gt;setToolTip(3, tooltip);</div><div class="line">    </div><div class="line">    emit newData(da);</div><div class="line">}</div></div><!-- fragment --><p>The picture below shows the application now completed.</p>
<div class="image">
<img src="CumbiaCustomWidgets1.png" alt="CumbiaCustomWidgets1.png"/>
<div class="caption">
The fully functional application</div></div>
<p>As you can see, there were seven successful readings from the <em>tango event system</em>, then an error occurred (15:52:48.4242) and the <em>cumbia-tango</em> engine switched to polling mode (see the line "successfully unsubscribed events..").</p>
<p>The <em>test/device/1</em> Tango device was still not responding to the poller at 15:52:48.4848 before going online again at 15:52:52. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 9 2019 16:48:56 for cumbia new control by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
