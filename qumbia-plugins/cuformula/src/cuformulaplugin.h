#ifndef CUFORMULASPLUGIN_H
#define CUFORMULASPLUGIN_H

#include <QGenericPlugin>
#include <QObject>
#include <cuformulaplugininterface.h>
#include <cuformulareader.h>

class CuControlsReaderFactoryI;
class CuFormulasPluginPrivate;


/**
 * \mainpage Formula plugin: enhance your application combining readings into formulas and functions
 *
 * \section intro_sec Introduction
 * CuFormulaPlugin lets you employ *sources* in the form of *javascript functions*,
 * rather than simple variable names exported by the control system(s) in use.
 *
 * \section usage_sec Usage
 *
 * \par 1. Load the plugin
 *
 * The application must first load the *formula plugin*.
 * Once loaded, the CuFormulaPlugin::initialize method must be called passing a
 * pointer to a previously allocated CumbiaPool and a reference to a CuControlsFactoryPool.
 * The CuFormulaPlugin::initialize function takes care of registering the default
 * "formula://" domain in CumbiaPool and CuControlsFactoryPool, by calling CumbiaPool::registerImpl
 * and CuControlsFactoryPool::setSrcPatterns
 *
 *
 * \code
   CuPluginLoader plulo;
   QString plupath = plulo.getPluginAbsoluteFilePath("", "cuformula-plugin.so");
   QPluginLoader pluginLoader(plupath);
   QObject *plugin = pluginLoader.instance();
   if (plugin){
        CuFormulaPluginI *fplu = qobject_cast<CuFormulaPluginI *>(plugin);
        if(fplu) {
            fplu->initialize(cu_pool, m_ctrl_factory_pool);
        } // else: error message
   } // else: error message
 * \endcode
 *
 *
 * \par 2. *formula* source syntax
 * As suggested by the discusssion above, in order to be interpreted by the plugin a *source* must
 * start with the "formula://" pattern.
 * The complete source expression will then contain the list of control system source names within
 * curly braces, comma separated, and a *javascript* function expressing the relations among the sources:
 *
 * \code
 * QString src = "formula://{a/test/device/att,b/test/device/att} function(a, b) { return a + b }"
 * my_sum_label->setSource(src); // let my_sum_label be a QuLabel
 * \endcode
 *
 * The result of the formula specified in the code will be displayed in the label.
 *
 * \par Example. la-cumparsita
 *
 * The image below shows formulas applied to a couple of waveforms generated by the *TangoTest* device.
 * You can see the *sum* and *diff* curves, calculated by *javascript* functions from the readings of
 * the two *wave* attributes.
 * On the right, two *QuLabel* show the average value of the waves for each of the two sources.
 *
 * \image html cumparsita.png "la-cumparsita shows a sum and a difference curve. Average labels on the right"
 * \image latex cumparsita.eps "cuuimake"
 *
 *
 * @brief The CuFormulaPlugin class
 */
class CuFormulaPlugin : public QObject,  public CuFormulaPluginI
{
    Q_OBJECT

#if QT_VERSION >= 0x050000
    Q_PLUGIN_METADATA(IID "org.qt-project.Qt.QGenericPluginFactoryInterface" FILE "cuformulasplugin.json")
#endif // QT_VERSION >= 0x050000

    Q_INTERFACES(CuFormulaPluginI)

public:
    CuFormulaPlugin(QObject *parent = nullptr);

    virtual ~CuFormulaPlugin();

    // QuActionExtensionPluginInterface interface
public:


private:
    CuFormulasPluginPrivate *d;

public:

    // CuFormulasPluginI interface
public:
    QString getName() const;
    Cumbia *getCumbia() const;
    void initialize(CumbiaPool *cu_poo, CuControlsFactoryPool &fpool);
    CuControlsReaderFactoryI* getFormulaReaderFactory() const;
    std::string message() const;
    bool error() const;
    std::vector<std::string> srcPatterns() const;
    void addSrcPattern(const std::string& pattern);
    CuFormulaParserI *getFormulaParserInstance() const;
};

#endif // CUFORMULASPLUGIN_H
