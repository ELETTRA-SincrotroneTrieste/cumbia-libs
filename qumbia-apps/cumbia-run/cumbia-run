#!/bin/bash

CURUN_PY=curun_db.py

# guess cumbia root from the path we are being executed
#
this_binpath="`dirname \"$0\"`"
CUMBIA_ROOT=`dirname $this_binpath`


CONF_FILE=$HOME/.config/cumbia/cumbia-run/options.sh
SQL_FILE=$HOME/.config/cumbia/cumbia-run/cumbia-run.db

SQL_DB_INIT_SCRIPT=$CUMBIA_ROOT/share/cumbia-run/curun-create-db.sql

UPDATE=0

declare -a args=( )
declare -a exports=()
declare -a tests=()
declare -a history_paths=()
declare -a context_from_history=()
lastcmd=""


# ------------------------------------------------------- get_args ---------------------------------------
function get_args {
	# the $1 used here is the first argument to the function
	# declare an array variable
    declare -a arr=("RUN" "RUN.txt" "run" "run.txt" "README" "README.txt" "README.md")
    ## now loop through the above array
    for i in "${arr[@]}"
    do
        input="$1/$i"  # $1: first arg to this function
        if [ -r $input ]; then

            while IFS= read -r line
            do
            if [[ $line =~ ^args\s+* ]]; then
                argus=${line#"args "}
                args+=("$argus")
            elif [[ $line =~ ^export\+* ]]; then
                exports+=("$line")
            elif [[ $line =~  ^\[test\]\s+* ]]; then
                test=${line#"[test] "}
                tests+=("$test")
            fi
             
            done < "$input"
        fi
    
    # or do whatever with individual element of the array
    done
}

# ------------------------------------------------------- get_contexts_from_history ---------------------------------------
function get_contexts_from_history {
	echo "get_contexts_from_history"
	app=$1 # $1 first arg passed to function
	hpa=`$CURUN_PY context $1`
	echo "contexts from history: got from python $hpa"
	contexts_from_history=($hpa)
}


# ------------------------------------------------------- try_exec_from_build_path ---------------------------------------
function args_from_build_path {
	if [ -d "$BUILD_PATH" ]; then
    	savedir=$PWD
    	REPO=$REPO_ROOT/$1
    	DESTDIR=$BUILD_PATH/$1
    	BINDIR=$DESTDIR/bin
    	if [ ! -d $DESTDIR ]; then
        	echo -e "\e[1.33m-\e[0m directory $DESTDIR does not exist. Do you want me to try to find and build the project $1 [y|n] ?"
			read yesno
			if [[ $yesno == "y" ]]; then
        		cumbia-build.sh $1
			fi
    	elif [ $UPDATE -ne 0 ]; then
        	cumbia-build.sh $1
    	fi	

    	if [ ! -d $BINDIR ]; then
            echo -e "\e[1;31m-\e[0m Could not find a binary for the project $projnam under $BINDIR."
            cumbia-build.sh $1
    	fi
    
		CMD=""
		
		if [ -x $BINDIR/$1-gui ]; then 
		    CMD=$BINDIR/$1-gui
		elif [ -x $BINDIR/$1 ]; then 
		    CMD=$BINDIR/$1
		fi
    
	    # args? get_args fills args, tests, exports arrays
    	get_args $DESTDIR

	else
    	echo -e "\e[1;31m:-(\e[0m the build path specified in the configuration does not exist"
	fi

}

# --------------------------------------------------- paths_from_history -----------------------------
function paths_from_history {
	echo "paths from history"
	app=$1 # $1 first arg passed to function
	hpa=`$CURUN_PY paths $1`
	echo "paths from history: got from python $hpa"
	history_paths=($hpa)
}

# --------------------------------------------------- rem_bin_suffix ---------------------------------

function rem_bin_suffix {
	suffixes=($IGNORE_BIN_SUFFIXES)
	app_no_suffix="$1"
	for i in "${suffixes[@]}"
	do
   		app_no_suffix=${app_no_suffix%"$i"}
	done
}

# -------------------------------------------------- get_path --------------------------------
function get_path {
	#  array of paths
	options=("$@")  
	exe_full_path=''

	echo "get pet: $1 and $2"
	for i in "${options[@]}"
	do
		echo "path $i"
	done
		
	
    c=0
	d=1
	len=${#options[@]}
	if [ $len -gt 1 ]; then
		for i in "${options[@]}"
        do
		    echo -e "$d. from \e[1;32m${options[$c]}\e[0m"
		    c=$((c+1))
		    d=$((d+1))
    		done
        echo -e -n "multiple executables found: choose one: \e[1;32m[1-$len]\e[0m "
        read choice
		if [[ $choice -ge 1 ]] && [[ $choice -le $len ]]; then
			exe_full_path=${options[$choice-1]}
		fi
	else
		exe_full_path=${options[0]}
	fi
}

# ------------------------------------------------------- run ---------------------------------------
# run the command
# expects exports, args and tests arrays
#
function run {
	lastcmd=""

	for i in "${exports[@]}"
        do
        ${exports[*]}
    done
    
    c=0
	d=1
    declare -a options=()
    
    for i in "${args[@]}"
        do
        options+=("$CMD ${args[$c]}")
        echo "$d. $CMD ${args[$c]}"
        c=$((c+1))
        d=$((d+1))
    done
    
      
    for i in "${tests[@]}"
        do
        t="${tests[*]}"
        t="${t/"[target]"/$CMD}" 
        options+=("$t")
        echo "$d. $t"
        c=$((c+1))
        d=$((d+1))
    done

	len=${#contexts_from_history[@]}
	if [ $len -gt 0 ]; then
		c=0
		echo -e "\e[0;32mfrom $CMD history: \e[0m"
		for i in "${contexts_from_history[@]}"
		    do
		    options+=("$CMD ${contexts_from_history[$c]}")
		    echo "$d. $CMD ${contexts_from_history[$c]}"
		    c=$((c+1))
		    d=$((d+1))
			done
	fi
    
    len=${#options[@]}
    if [ $len -gt 1 ]; then
        echo -e -n "Which command would you like to execute [1-$len]? "
        read choice
    

        if [[ $choice -ge 1 ]] && [[ $choice -le $len ]]; then
            echo "will execute $choice: --> ${options[$choice-1]}"
            lastcmd=${options[$choice-1]}
            # launch the program
            eval $lastcmd
        else
            echo -e "\e[1.31m-\e[0m invalid choice\n"
        fi
    elif [ $len -eq 1 ]; then
		lastcmd=${options[0]}
        eval $lastcmd
    fi
}


# Test for configuration file existence
#
if test -f "$CONF_FILE"; then
    . $CONF_FILE
else
    echo "First time you run cumbia run? Execute cumbia build setup"
    exit 0
fi

# Test for sqlite3 installed
#
if ! command -v sqlite3 &> /dev/null; then
    echo -e "\e[1;32minstall \e4msqlite3\e[0m \e[1;32mfor additional functionality\e[0m (recommended)"
    has_sqlite3=0
else
	has_sqlite3=1
	if [ ! -f $SQL_FILE ]; then
		echo -e -n "creating database file..."
		sqlite3 $SQL_FILE <  $SQL_DB_INIT_SCRIPT
	fi
fi

#
# -------------------------- main ----------------------------------
# --------------------------      ----------------------------------
#

if [ -z "$1" ] || [[ "$1" == "-a" ]]; then
	#
	# executed without params: find an executable here or under 'bin'
	#
    projnam=`basename $PWD`
	argums=""
	path=""
    if [ ! -x bin/$projnam ] && [ ! -x bin/$projnam-gui ] && [ ! -x $projnam-gui ] && [ ! -x $projnam-gui ]; then
        echo -e "\e[1;31m-\e[0m Could not find a binary for the project $projnam under $PWD."
        echo -e "\e[1;31m-\e[0m Type \e[4mcumbia build $projnam\e[0m"
        exit 1
	else
		if [ $1 == "-a" ]; then
			argums="${@:2}"
			echo "detected args $args"
		fi
		# execute in this dir, right here or under bin/
		#
		if [ -x bin/$projnam ]; then
			exe=$PWD/bin/$projnam
		elif [ -x $projnam ]; then
			exe=$PWD/$projnam
		# -gui
		elif [ -x bin/$projnam-gui ]; then
			exe=$PWD/bin/$projnam-gui
		elif [ -x $projnam-gui ]; then
			exe=$PWD/$projnam-gui
		fi

	
		# execute p
		if [ ! -z $args ]; then				
			# 1. with arguments specified with "-a" :
			line="$p $args"
		else
			# 2. find arguments from README or run files in this dir
			echo "cumbia-run: getting args from $PWD"
			get_args $PWD  # fills args, tests, exports
			CMD=$exe
			run
		fi

		eval $line
	
		res=$?
		#
		# successful ?
		#
		if [ $res -eq 0 ] && [ ! -z "$lastcmd" ]; then
			lastcmd_array=($lastcmd)
			app="${lastcmd_array[0]}"
			a="${lastcmd_array[1]}"  
			echo "success executing with exe $app amd args $a"
			rem_bin_suffix $app
			$CURUN_PY add -c "$app_no_suffix" -a "$a"  # $? is the return value from function
		fi
    fi
elif [[ $1 == *"/"* ]]; then
	eval $@
	if [ $? -eq 0 ]; then
		args="${@:2}"
		p=$1
		# curun-db.py add -c path/to/app -a arg1 arg2 ... argN  -e VARIABLE1=val1
		rem_bin_suffix $p
		$CURUN_PY add -c "$app_no_suffix" -a "$args"  # $? is the return value from function

	fi

else
	# run with a command line arg and not absolute path
	# assume first command line arg is app name
	echo "will try to run app $1"
	paths_from_history $1
	args_from_build_path $1
	get_contexts_from_history $1


	echo ""

	get_path "${history_paths[@]}"

	echo "chosen path is " $exe_full_path
	CMD=$exe_full_path

	echo "contexts from historw goten" 
	echo "${contexts_from_history[@]}"

	run
	

	echo "${args[@]}"
	echo $exports
	echo $tests

fi

